{
  "slug": "async-programming",
  "title": "Асинхронное программирование в JavaScript",
  "description": "Изучите механизмы асинхронного выполнения кода: callbacks, Promises, async/await и Event Loop.",
  "difficulty": "intermediate",
  "duration": 45,
  "time":16,
  "theory": "## Введение в асинхронность\n\nJavaScript — однопоточный язык программирования, выполняющий одну операцию за раз. Однако веб-приложения требуют множества одновременных операций: HTTP-запросы, таймеры, обработку событий, анимации. Асинхронное программирование позволяет выполнять длительные операции без блокировки основного потока.\n\n## Синхронный vs Асинхронный код\n\n### Синхронный код\nВыполняется последовательно:\n```javascript\nconsole.log('1');\nconsole.log('2');\nconsole.log('3');\n// Вывод: 1, 2, 3\n```\n\n### Асинхронный код\nНе блокирует выполнение:\n```javascript\nconsole.log('Начало');\nsetTimeout(() => console.log('Таймер'), 0);\nconsole.log('Конец');\n// Вывод: Начало, Конец, Таймер\n```\n\n## Event Loop (Цикл событий)\n\nJavaScript использует однопоточную модель с Event Loop:\n\n1. **Call Stack** — стек синхронных операций\n2. **Web APIs** — браузерные асинхронные API\n3. **Callback Queue** — очередь готовых коллбэков\n4. **Microtask Queue** — очередь микрозадач (Promises)\n\n### Алгоритм работы:\n1. Выполнить все задачи из Call Stack\n2. Выполнить все микрозадачи из Microtask Queue\n3. Выполнить одну задачу из Callback Queue\n4. Повторить\n\n## Callback функции\n\nCallback — функция, передаваемая как аргумент и вызываемая после операции:\n\n```javascript\nsetTimeout(() => {\n    console.log('Callback выполнен');\n}, 1000);\n```\n\n### Проблема Callback Hell\nЧрезмерная вложенность создает трудночитаемый код:\n```javascript\ngetData1((err1, data1) => {\n    getData2(data1, (err2, data2) => {\n        getData3(data2, (err3, data3) => {\n            // ...\n        });\n    });\n});\n```\n\n## Promises (Обещания)\n\n### Концепция Promises\nPromise — объект, представляющий результат асинхронной операции с тремя состояниями:\n1. **pending** — ожидание\n2. **fulfilled** — успешно завершено\n3. **rejected** — завершено с ошибкой\n\n### Создание Promise\n```javascript\nconst promise = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        const success = true;\n        if (success) {\n            resolve('Успех');\n        } else {\n            reject(new Error('Ошибка'));\n        }\n    }, 1000);\n});\n```\n\n### Использование Promise\n```javascript\npromise\n    .then(result => {\n        console.log('Успех:', result);\n        return result.toUpperCase();\n    })\n    .then(processed => {\n        console.log('Обработано:', processed);\n    })\n    .catch(error => {\n        console.error('Ошибка:', error.message);\n    })\n    .finally(() => {\n        console.log('Завершено');\n    });\n```\n\n### Статические методы Promise\n```javascript\n// Ожидание всех промисов\nPromise.all([promise1, promise2])\n    .then(results => console.log('Все выполнены'))\n    .catch(error => console.log('Один провалился'));\n\n// Первый выполненный промис\nPromise.race([promise1, promise2])\n    .then(first => console.log('Первый:', first));\n```\n\n## Async/Await\n\n### Синтаксический сахар над Promises\n`async` и `await` позволяют писать асинхронный код в синхронном стиле.\n\n### Объявление async функции\n```javascript\nasync function getUser() {\n    return { name: 'Анна', age: 25 };\n}\n// Всегда возвращает Promise\n```\n\n### Использование await\n```javascript\nasync function loadData() {\n    try {\n        const user = await getUser();\n        const posts = await getPosts(user.id);\n        console.log('Данные:', posts);\n    } catch (error) {\n        console.error('Ошибка:', error);\n    }\n}\n```\n\n### Обработка ошибок\n```javascript\n// Способ 1: try...catch\nasync function safeFetch() {\n    try {\n        return await fetchData();\n    } catch (error) {\n        console.error('Ошибка:', error);\n        return null;\n    }\n}\n\n// Способ 2: catch для Promise\nasync function safeFetch2() {\n    const data = await fetchData().catch(error => {\n        console.error('Ошибка:', error);\n        return defaultValue;\n    });\n    return data;\n}\n```\n\n## Практическое применение\n\n### HTTP-запросы с Fetch API\n```javascript\nasync function fetchUser(userId) {\n    try {\n        const response = await fetch(`/api/users/${userId}`);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP ${response.status}`);\n        }\n        \n        return await response.json();\n    } catch (error) {\n        console.error('Ошибка запроса:', error);\n        throw error;\n    }\n}\n```\n\n### Таймеры\n```javascript\n// Однократное выполнение\nconst timeoutId = setTimeout(() => {\n    console.log('Прошло 2 секунды');\n}, 2000);\n\n// Повторяющееся выполнение\nconst intervalId = setInterval(() => {\n    console.log('Секунда прошла');\n}, 1000);\n\n// Очистка\nclearTimeout(timeoutId);\nclearInterval(intervalId);\n```\n\n## Микрозадачи и макрозадачи\n\n### Различия\n**Микрозадачи:** Promise callbacks, queueMicrotask, MutationObserver\n**Макрозадачи:** setTimeout, setInterval, I/O операции, UI рендеринг\n\n### Порядок выполнения\n```javascript\nconsole.log('1');\nsetTimeout(() => console.log('2'), 0);\nPromise.resolve().then(() => console.log('3'));\nconsole.log('4');\n// Вывод: 1, 4, 3, 2\n```\n\n## Паттерны асинхронного программирования\n\n### Параллельное выполнение\n```javascript\nasync function parallelLoad() {\n    const [user, posts, comments] = await Promise.all([\n        getUser(),\n        getPosts(),\n        getComments()\n    ]);\n    return { user, posts, comments };\n}\n```\n\n### Последовательное выполнение\n```javascript\nasync function sequentialLoad() {\n    const step1 = await doStep1();\n    const step2 = await doStep2(step1);\n    const step3 = await doStep3(step2);\n    return step3;\n}\n```\n\n## Обработка ошибок\n\n### Глобальные обработчики\n```javascript\n// Необработанные ошибки Promises\nwindow.addEventListener('unhandledrejection', event => {\n    console.error('Необработанная ошибка:', event.reason);\n});\n\n// Другие асинхронные ошибки\nwindow.addEventListener('error', event => {\n    console.error('Ошибка выполнения:', event.error);\n});\n```\n\n## Оптимизация производительности\n\n### Избегание лишних await\n```javascript\n// Медленно\nasync function slow() {\n    const a = await getA();\n    const b = await getB();\n    return { a, b };\n}\n\n// Быстро\nasync function fast() {\n    const aPromise = getA();\n    const bPromise = getB();\n    \n    const a = await aPromise;\n    const b = await bPromise;\n    \n    return { a, b };\n}\n```\n\n### Кэширование\n```javascript\nconst cache = new Map();\n\nasync function getCached(key) {\n    if (cache.has(key)) {\n        return cache.get(key);\n    }\n    \n    const data = await fetchData(key);\n    cache.set(key, data);\n    return data;\n}\n```\n\n## Лучшие практики\n\n1. **Всегда обрабатывайте ошибки** — используйте try...catch или .catch()\n2. **Избегайте глубокой вложенности** — используйте async/await\n3. **Используйте Promise.all для независимых операций**\n4. **Ограничивайте параллельные запросы** для предотвращения перегрузки\n5. **Освобождайте ресурсы** — очищайте таймеры и обработчики\n6. **Используйте патерны повторных попыток** для ненадежных операций\n7. **Логируйте ошибки** для отладки\n8. **Тестируйте асинхронный код** корректно\n\n## Заключение\n\nАсинхронное программирование — ключевая концепция JavaScript для создания современных веб-приложений. Понимание Event Loop, умение работать с Promises и async/await — обязательные навыки разработчика.\n\nПреимущества асинхронного подхода:\n- Неблокирующее выполнение операций\n- Улучшенная производительность\n- Лучший пользовательский опыт\n- Возможность обработки множества одновременных операций\n\nОсвоение этих концепций позволяет создавать быстрые, отзывчивые и надежные приложения.",
  
  "points": [
    "Принципы асинхронного программирования",
    "Event Loop и модель выполнения",
    "Callback функции и их ограничения",
    "Promises: создание и использование",
    "Async/await для читаемого кода",
    "Обработка ошибок в асинхронных операциях",
    "HTTP-запросы с Fetch API",
    "Таймеры и задержки выполнения",
    "Микрозадачи и макрозадачи",
    "Паттерны асинхронного программирования",
    "Оптимизация производительности",
    "Лучшие практики"
  ],
  
  "lesson": {
    "slug": "oop",
    "title": "Объектно-ориентированное программирование"
  }
}