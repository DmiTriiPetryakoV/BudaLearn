{
  "slug": "html5-features",
  "title": "HTML5 — Современные Возможности",
  "description": "Полное руководство по HTML5: новые семантические элементы, API, мультимедиа, формы, хранилище данных и современные возможности веб-платформы",
  "difficulty": "intermediate",
  "duration": 60,
  "time": 45,
  "theory": "## HTML5 — Современные Возможности: Полное Руководство\n\n### Введение в HTML5\n\nHTML5 — пятая версия языка разметки HTML, представленная в 2014 году консорциумом W3C. Это не просто обновление, а революционный шаг в развитии веб-платформы, который принес множество нововведений: семантические элементы для структурирования контента, нативную поддержку аудио и видео без плагинов, мощные JavaScript API для создания веб-приложений, улучшенные формы с валидацией, офлайн возможности и локальное хранилище, графические возможности через Canvas и SVG, геолокацию и доступ к устройствам. HTML5 позволил создавать полноценные веб-приложения, конкурирующие с нативными, устранил зависимость от плагинов типа Flash, улучшил доступность и семантику, ускорил разработку благодаря встроенным возможностям.\n\n### История и Эволюция HTML\n\n**До HTML5:**\n\nHTML 1.0 (1991) — базовая разметка Тима Бернерса-Ли, содержавшая всего около 20 тегов. HTML 2.0 (1995) — первый официальный стандарт IETF. HTML 3.2 (1997) — добавил таблицы, апплеты, обтекание текстом. HTML 4.01 (1999) — улучшенная семантика, разделение структуры и презентации, поддержка CSS. XHTML 1.0 (2000) — XML-версия HTML, строгий синтаксис, обязательное закрытие тегов. XHTML 2.0 (заброшен) — нереалистичные цели, обратная несовместимость.\n\n**HTML5 Era:**\n\n2004 — WHATWG начинает работу над Web Applications 1.0. 2008 — первый публичный draft HTML5. 2014 — HTML5 стал рекомендацией W3C. 2016 — HTML 5.1. 2017 — HTML 5.2. Настоящее — HTML Living Standard (постоянно развивается).\n\n**Философия HTML5:** Обратная совместимость — старый код работает. Практичность над чистотой — реальные решения для реальных задач. Четкие правила парсинга — одинаковая обработка во всех браузерах. Открытость и доступность — бесплатные стандарты.\n\n### Новые Семантические Элементы\n\n**Структурные Элементы:**\n\n**header:** Шапка страницы или секции. Содержит навигацию, логотип, заголовки. Может быть несколько на странице. Не путать с head.\n\n**nav:** Блок навигационных ссылок. Для основной навигации сайта. Не для всех групп ссылок. Улучшает доступность — landmark для скринридеров.\n\n**main:** Основное уникальное содержимое документа. Только один на странице. Не вкладывается в article, aside, footer, header, nav. Прямой доступ для вспомогательных технологий.\n\n**article:** Независимый, самодостаточный контент. Может быть извлечен и опубликован отдельно. Блог-пост, новость, комментарий, виджет. Может содержать вложенные article.\n\n**section:** Тематическая группировка контента. Должна иметь заголовок. Для логического разделения документа. Не использовать как общий контейнер (для этого div).\n\n**aside:** Контент, косвенно связанный с основным. Сайдбары, врезки, рекламные блоки. Может быть удален без потери смысла основного контента.\n\n**footer:** Подвал страницы или секции. Авторская информация, копирайт, ссылки. Может быть несколько на странице. Не обязательно внизу визуально.\n\n**Контентные Элементы:**\n\n**figure и figcaption:** Самодостаточный контент с подписью. Изображения, диаграммы, код, цитаты. Семантическая связь контента и подписи.\n\n**mark:** Выделение текста для справки. Подсветка поискового запроса. Важный фрагмент в цитате. Визуально — желтый фон.\n\n**time:** Дата, время или продолжительность. Машиночитаемый формат в datetime. Помогает поисковикам и календарям.\n\n**details и summary:** Раскрывающийся виджет disclosure. Summary — заголовок, всегда виден. Нативная функциональность без JavaScript. Атрибут open для раскрытого состояния.\n\n**dialog:** Диалоговое или модальное окно. Методы show() и showModal(). Нативное управление фокусом. Backdrop через CSS ::backdrop.\n\n**Удаленные Элементы:** HTML5 удалил устаревшие, презентационные элементы: font, center, big, strike, frame, frameset, acronym (используйте abbr). Их функции перенесены в CSS.\n\n### Canvas API\n\n**Что такое Canvas:** Элемент для рисования графики через JavaScript. Растровая графика (в отличие от векторного SVG). Динамическое создание изображений. Игры, визуализации, редакторы.\n\n**Базовое Использование:** Создание canvas элемента с размерами. Получение 2D контекста через getContext('2d'). Рисование примитивов: прямоугольники, круги, линии. Заливка и обводка. Градиенты и паттерны.\n\n**2D Context API:**\n\nПрямоугольники: fillRect, strokeRect, clearRect. Пути: beginPath, moveTo, lineTo, arc, fill, stroke. Стили: fillStyle, strokeStyle, lineWidth. Градиенты: createLinearGradient, createRadialGradient. Текст: fillText, strokeText, font, textAlign. Изображения: drawImage. Трансформации: translate, rotate, scale, save, restore. Композиция: globalCompositeOperation, globalAlpha.\n\n**Анимация:** Очистка canvas. Рисование кадра. requestAnimationFrame() для плавности. Управление состоянием объектов.\n\n**WebGL Context:** 3D графика на GPU. Низкоуровневый API. Библиотеки: Three.js, Babylon.js. Высокая производительность для игр.\n\n**Доступность Canvas:** Canvas недоступен для скринридеров. Fallback контент внутри тега. Альтернативное текстовое описание. ARIA атрибуты.\n\n### Аудио и Видео\n\n**Нативная Мультимедиа:** До HTML5 требовались плагины (Flash, QuickTime). HTML5 принес нативную поддержку. Унифицированный API. Доступность и безопасность.\n\n**Элемент Video:**\n\nБазовые атрибуты: src — источник видео, controls — показать элементы управления, autoplay — автовоспроизведение (с ограничениями), loop — зацикливание, muted — без звука, poster — изображение-заглушка, preload — предзагрузка (none, metadata, auto), width, height — размеры.\n\n**Множественные Источники:** source элемент для разных форматов. type атрибут с MIME типом. Браузер выбирает первый поддерживаемый. Fallback контент для старых браузеров.\n\n```html\n<video controls width=\"640\">\n    <source src=\"video.mp4\" type=\"video/mp4\">\n    <source src=\"video.webm\" type=\"video/webm\">\n    Ваш браузер не поддерживает видео.\n</video>\n```\n\n**Форматы Видео:** MP4 (H.264) — лучшая совместимость, все браузеры. WebM (VP9) — открытый, хорошее сжатие. Ogg (Theora) — устарел.\n\n**Элемент Audio:** Аналогично video, без визуальной части. Те же атрибуты и API. Форматы: MP3 (универсален), WAV (без сжатия), Ogg Vorbis, AAC.\n\n**Media API:**\n\nСвойства: currentTime, duration, paused, ended, volume, playbackRate, muted, readyState.\nМетоды: play() (возвращает Promise), pause(), load(), canPlayType(type).\nСобытия: play, pause, ended, timeupdate, volumechange, loadedmetadata, loadeddata, error, canplay, seeking, seeked.\n\n**Треки и Субтитры:** track элемент для текстовых треков. WebVTT формат. kind: subtitles, captions, descriptions, chapters. srclang — язык. label — название. default — по умолчанию.\n\n**Кастомные Плееры:** Скрытие стандартных контролов. Создание своего UI. Привязка к Media API. Полный контроль над дизайном и функциональностью.\n\n### Улучшенные Формы HTML5\n\n**Новые Типы Input:**\n\nemail — валидация email адреса, специальная клавиатура на мобильных, атрибут multiple для нескольких адресов. url — валидация URL, клавиатура с / и .com. tel — поле для телефона, цифровая клавиатура на мобильных, нет автоматической валидации. number — числовое поле с кнопками, атрибуты min, max, step. range — слайдер для выбора числа. date — выбор даты через календарь, формат YYYY-MM-DD. time — выбор времени. datetime-local — дата и время без часового пояса. month — выбор месяца и года. week — выбор недели года. color — выбор цвета через палитру, hex формат. search — поле поиска с кнопкой очистки.\n\n**Новые Атрибуты:**\n\nplaceholder — подсказка внутри поля. autofocus — автоматический фокус при загрузке (только один на странице). autocomplete — управление автозаполнением (on, off, токены). required — обязательное поле, встроенная валидация. pattern — регулярное выражение для валидации. min, max — минимальное и максимальное значение. step — шаг изменения значения. minlength, maxlength — ограничение длины текста. multiple — множественный выбор (email, file, select). list — связь с datalist для автодополнения.\n\n**Элемент Datalist:** Список предложенных значений. Работает как автодополнение. Пользователь может ввести свое. Связь через атрибут list.\n\n**Элемент Output:** Результат вычислений. Семантически правильный для выводимых данных. Атрибут for — связь с элементами вычисления.\n\n**Валидация Форм:**\n\nВстроенная валидация — браузер проверяет перед отправкой на основе атрибутов. Автоматические сообщения об ошибках. Отключение через novalidate.\n\nПсевдоклассы: :valid, :invalid, :required, :optional, :in-range, :out-of-range.\n\nConstraint Validation API: setCustomValidity(message) — кастомное сообщение, checkValidity() — проверка валидности, reportValidity() — показать сообщения, validity — объект с деталями ошибки, validationMessage — текст сообщения.\n\n### Web Storage API\n\n**До HTML5:** Только cookies для хранения. Ограничение 4 КБ. Отправляются с каждым запросом. Неудобный API.\n\n**localStorage:** Постоянное хранилище в браузере. Данные не удаляются при закрытии. Лимит ~5-10 МБ. Синхронный API. Только строки (сериализуйте объекты).\n\nМетоды: setItem(key, value), getItem(key), removeItem(key), clear(), key(index), length.\n\n**sessionStorage:** Хранилище на время сессии вкладки. Удаляется при закрытии вкладки. Тот же API. Изолировано между вкладками. Лимит ~5-10 МБ.\n\n**Использование:** Сохранение настроек пользователя. Кеширование данных. Сохранение состояния приложения. Черновики форм. Токены аутентификации (с осторожностью).\n\n**Сериализация:** Storage хранит только строки. JSON.stringify() для сохранения объектов. JSON.parse() для восстановления.\n\n**События Storage:** Событие storage при изменении в другой вкладке. Синхронизация между вкладками. Свойства: key, oldValue, newValue, url.\n\n**Безопасность:** Storage доступен JavaScript. XSS уязвимости опасны. Не храните чувствительные данные. Шифруйте важную информацию. Same-origin policy защищает.\n\n### Геолокация API\n\n**Geolocation API:** Определение местоположения пользователя. Требует разрешения пользователя. Работает через GPS, Wi-Fi, IP. Координаты широты и долготы.\n\n**Методы:**\n\ngetCurrentPosition(success, error, options) — однократное получение позиции. success callback с координатами. error callback при ошибке. options — настройки точности.\n\nwatchPosition(success, error, options) — отслеживание изменений позиции. Вызов callback при перемещении. Возвращает ID для остановки. clearWatch(id) — остановить отслеживание.\n\n**Position Object:** coords.latitude — широта, coords.longitude — долгота, coords.accuracy — точность в метрах, coords.altitude — высота, coords.speed — скорость, timestamp — время получения.\n\n**Options:** enableHighAccuracy — высокая точность (GPS), timeout — максимальное время ожидания, maximumAge — максимальный возраст кешированных данных.\n\n**Обработка Ошибок:** PERMISSION_DENIED — пользователь отказал, POSITION_UNAVAILABLE — невозможно определить, TIMEOUT — превышено время ожидания.\n\n**Использование:** Карты и навигация. Локальный поиск. Персонализация контента. Доставка и логистика. Геотаргетинг рекламы.\n\n**Приватность:** Всегда требует разрешения. Пользователь контролирует доступ. HTTPS обязателен для геолокации. Объясняйте зачем нужны данные.\n\n### Drag and Drop API\n\n**Нативное Перетаскивание:** HTML5 API для drag and drop. Без внешних библиотек. Работает с файлами и элементами.\n\n**Перетаскиваемые Элементы:** Атрибут draggable=\"true\". По умолчанию: изображения, ссылки, выделенный текст. Любой элемент можно сделать draggable.\n\n**События Перетаскивания:**\n\nНа перетаскиваемом: dragstart — начало, drag — во время, dragend — конец.\nНа целевом: dragenter — вход в зону, dragover — перемещение над зоной, dragleave — выход, drop — сброс.\n\n**DataTransfer Object:** setData(format, data), getData(format), effectAllowed — разрешенные операции (copy, move, link), dropEffect — эффект сброса, files — перетаскиваемые файлы.\n\n**Основной Паттерн:** dragstart — установка данных. dragover — preventDefault() для разрешения drop. drop — получение данных и обработка. Визуальная обратная связь через CSS.\n\n**Перетаскивание Файлов:** Событие drop на зоне. dataTransfer.files — FileList объект. Обработка загрузки через FileReader. Валидация типов и размера.\n\n**Использование:** Сортировка списков. Загрузка файлов. Drag and drop интерфейсы. Канбан доски. Конструкторы.\n\n### File API\n\n**Работа с Файлами:** Доступ к файлам с устройства. Чтение содержимого. Информация о файлах. Без отправки на сервер.\n\n**File Input:** <input type=\"file\">. files свойство — FileList. multiple — несколько файлов. accept — ограничение типов.\n\n**File Object:** Наследует Blob. name — имя, size — размер в байтах, type — MIME тип, lastModified — дата изменения.\n\n**FileReader API:** Асинхронное чтение содержимого файлов.\n\nМетоды: readAsText(file), readAsDataURL(file), readAsArrayBuffer(file), readAsBinaryString(file).\nСобытия: load — успешное чтение, error — ошибка, progress — прогресс, loadstart, loadend.\n\n**Использование:** Превью изображений перед загрузкой. Клиентская валидация файлов. Чтение CSV, JSON файлов. Редакторы текста. Обработка изображений.\n\n**Drag and Drop Файлов:** Комбинация File API и Drag and Drop. dropzone для зоны сброса. dataTransfer.files для получения.\n\n### History API\n\n**Управление Историей:** Программное управление браузерной историей. Без перезагрузки страницы. Для Single Page Applications. Работа с URL.\n\n**Методы:**\n\npushState(state, title, url) — добавляет запись в историю. state — объект состояния, title — заголовок (игнорируется), url — новый URL.\n\nreplaceState(state, title, url) — заменяет текущую запись. Не создает новую запись.\n\nback(), forward(), go(n) — навигация по истории.\n\n**Событие popstate:** Срабатывает при навигации (кнопки назад/вперед). pushState/replaceState НЕ вызывают. event.state — сохраненное состояние.\n\n**Использование в SPA:** Изменение URL без перезагрузки. Сохранение состояния приложения. Работа кнопок браузера. Букмаркинг состояний.\n\n**Паттерн Использования:** Перехват кликов по ссылкам. preventDefault() на навигации. pushState() с новым URL. Загрузка контента через AJAX. Обновление DOM. Обработка popstate.\n\n### Web Workers\n\n**Многопоточность в Браузере:** JavaScript однопоточный. Тяжелые вычисления блокируют UI. Web Workers — фоновые потоки. Не блокируют главный поток.\n\n**Создание Worker:** new Worker('worker.js'). Отдельный JavaScript файл. Изолированный контекст. Нет доступа к DOM.\n\n**Коммуникация:**\n\nИз Main Thread: worker.postMessage(data) — отправка, worker.onmessage — получение, worker.onerror — ошибки, worker.terminate() — остановка.\n\nИз Worker: postMessage(data) — отправка, onmessage — получение, importScripts() — загрузка скриптов, close() — самоостановка.\n\n**Передача Данных:** Структурированное клонирование — копирование данных (медленно). Transferable Objects — передача владения (быстро).\n\n**Типы Workers:**\n\nDedicated Workers — привязаны к создавшему скрипту, один владелец.\nShared Workers — доступны из нескольких скриптов, общий контекст.\nService Workers — прокси между приложением и сетью, офлайн, push, background sync.\n\n**Использование:** Обработка больших данных. Сложные вычисления. Парсинг файлов. Криптография. Обработка изображений. Без блокировки UI.\n\n**Ограничения:** Нет доступа к DOM. Нет window, document. Ограниченный API браузера. Коммуникация только через messages.\n\n### Offline и Service Workers\n\n**Application Cache (устарел):** Первая попытка офлайн приложений. DEPRECATED — не используйте. Множество проблем: сложный, непредсказуемый, проблемы с обновлением.\n\n**Service Workers:** Полный контроль над кешированием. Программное управление запросами. Стратегии кеширования. Офлайн-первый подход. Background sync. Push уведомления.\n\nЖизненный цикл: Register → Install → Activate → Fetch.\n\nСтратегии кеширования: Cache First, Network First, Stale-While-Revalidate, Cache Only, Network Only.\n\n### IndexedDB\n\n**Клиентская База Данных:** NoSQL база в браузере. Хранение больших объемов структурированных данных. Асинхронный API. Индексирование для быстрого поиска.\n\n**Основные Концепции:**\n\nБаза Данных — контейнер для хранилищ, версионирование схемы.\nObject Store — аналог таблицы, хранит объекты, ключ-значение.\nIndex — индекс по свойству объекта, ускоряет поиск.\nTransaction — атомарные операции, readonly или readwrite.\nCursor — итерация по объектам, фильтрация и сортировка.\n\n**Основные Операции:**\n\nОткрытие БД: indexedDB.open(name, version). Событие upgradeneeded для миграций. Создание object stores.\n\nДобавление: transaction.objectStore().add() или put().\nЧтение: get(key), getAll(), cursor.\nОбновление: put() с существующим ключом.\nУдаление: delete(key), clear().\n\n**Использование:** Офлайн данные приложений. Кеш больших наборов данных. Синхронизация с сервером. Progressive Web Apps.\n\n**Сравнение с localStorage:** localStorage — до 10 МБ, синхронный, только строки. IndexedDB — до сотен МБ, асинхронный, структурированные данные.\n\n### WebSockets\n\n**Постоянное Соединение:** Двусторонняя коммуникация. Реальное время. Без polling. Работает поверх TCP.\n\n**Создание Подключения:** new WebSocket('ws://example.com'). wss:// для защищенного соединения. Событие open при подключении.\n\n**События:** open — соединение установлено, message — получено сообщение, error — ошибка, close — соединение закрыто.\n\n**Методы:** send(data) — отправка (строка, Blob, ArrayBuffer), close() — закрытие.\n\n**Свойства:** readyState — состояние (CONNECTING, OPEN, CLOSING, CLOSED), bufferedAmount — данные в очереди.\n\n**Использование:** Чаты в реальном времени. Онлайн игры. Live обновления. Коллаборативное редактирование. Финансовые тикеры. Уведомления.\n\n### Новые JavaScript API\n\n**Intersection Observer:** Отслеживание видимости элементов. Ленивая загрузка изображений. Бесконечная прокрутка. Аналитика видимости.\n\n**Mutation Observer:** Отслеживание изменений DOM. Добавление/удаление элементов. Изменение атрибутов и текста.\n\n**Resize Observer:** Отслеживание изменений размера элементов. Адаптивные компоненты.\n\n**Performance API:** Измерение производительности. Navigation Timing, Resource Timing, User Timing.\n\n**Fetch API:** Современная замена XMLHttpRequest. Promise-based. Работа с Response и Request объектами.\n\n**Notifications API:** Системные уведомления. Требует разрешения. Работает вне браузера.\n\n**Vibration API:** Вибрация на мобильных. navigator.vibrate(pattern). Тактильная обратная связь.\n\n### Лучшие Практики HTML5\n\n1. Используйте семантические элементы вместо div.\n2. Один main, header, footer на странице.\n3. DOCTYPE html — простой и достаточный.\n4. Валидный HTML5 код.\n5. Прогрессивное улучшение — работа без JS.\n6. Feature detection вместо browser detection.\n7. Полифиллы для старых браузеров.\n8. Доступность — ARIA где необходимо.\n9. Производительность — ленивая загрузка, оптимизация.\n10. Безопасность — валидация на сервере.\n11. Мобильная адаптивность.\n12. Офлайн функциональность через Service Workers.\n13. Web Storage с осторожностью к безопасности.\n14. Canvas fallback контент.\n15. Тестирование в разных браузерах.\n\n### Совместимость и Поддержка\n\n**Проверка Поддержки:** caniuse.com — таблицы совместимости. Modernizr — feature detection библиотека. @supports в CSS. JavaScript проверки API.\n\n**Полифиллы:** Эмуляция новых API в старых браузерах. html5shiv — для IE8. Polyfill.io — автоматический набор. Внимание к размеру бандла.\n\n**Прогрессивное Улучшение:** Базовая функциональность для всех. Улучшения для современных браузеров. Graceful degradation. Никто не остается без контента.\n\n**Вечнозеленые Браузеры:** Современные браузеры автообновляются. Chrome, Firefox, Edge, Safari. Поддержка последних стандартов.\n\n### Заключение\n\nHTML5 революционизировал веб-разработку, предоставив мощные инструменты для создания современных веб-приложений. Семантические элементы улучшили структуру и доступность, мультимедиа API устранили зависимость от плагинов, JavaScript API открыли новые возможности, хранилище и офлайн функции приблизили веб к нативным приложениям. HTML5 — это живой стандарт, постоянно развивающийся. Освоение HTML5 — обязательное условие для современного фронтенд-разработчика, открывающее путь к созданию богатых, интерактивных, доступных веб-приложений.",
  
  "points": [
    "История и эволюция от HTML 1.0 до HTML5",
    "Семантические элементы: header, nav, main, article, section, aside, footer",
    "Контентные элементы: figure, mark, time, details, dialog",
    "Canvas API для 2D графики и анимации",
    "WebGL для 3D графики",
    "Нативные audio и video элементы",
    "Media API для управления воспроизведением",
    "Новые типы input: email, url, tel, number, range, date, color",
    "Новые атрибуты форм: placeholder, autofocus, required, pattern",
    "Datalist для автодополнения",
    "Встроенная валидация форм и Constraint Validation API",
    "Web Storage: localStorage и sessionStorage",
    "Geolocation API для определения местоположения",
    "Drag and Drop API",
    "File API для работы с файлами",
    "History API для управления историей браузера",
    "Web Workers для многопоточности",
    "Service Workers и офлайн возможности",
    "IndexedDB для клиентской базы данных",
    "WebSockets для реального времени",
    "Новые JavaScript API: Intersection Observer, Mutation Observer",
    "Совместимость и полифиллы",
    "Прогрессивное улучшение",
    "Лучшие практики HTML5"
  ],
  
  "lesson": {
    "slug": "html-best-practices",
    "title": "Лучшие Практики HTML"
  }
}