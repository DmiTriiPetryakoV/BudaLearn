{
  "slug": "html5-features",
  "title": "HTML5 — Современные Возможности",
  "description": "Полное руководство по HTML5: новые семантические элементы, API, мультимедиа, формы, хранилище данных и современные возможности веб-платформы",
  "difficulty": "intermediate",
  "duration": 60,
  "time":11,
  "theory": "HTML5 — Современные Возможности: Полное Руководство\n\n### Введение в HTML5\n\nHTML5 — пятая версия языка разметки HTML, представленная в 2014 году консорциумом W3C. Это не просто обновление, а революционный шаг в развитии веб-платформы, который принес множество нововведений: семантические элементы для структурирования контента, нативную поддержку аудио и видео без плагинов, мощные JavaScript API для создания веб-приложений, улучшенные формы с валидацией, офлайн возможности и локальное хранилище, графические возможности через Canvas и SVG, геолокацию и доступ к устройствам. HTML5 позволил создавать полноценные веб-приложения, конкурирующие с нативными, устранил зависимость от плагинов типа Flash, улучшил доступность и семантику, ускорил разработку благодаря встроенным возможностям.\n\n### История и Эволюция HTML\n\n**До HTML5:**\n- **HTML 1.0 (1991)** — базовая разметка Тима Бернерса-Ли\n- **HTML 2.0 (1995)** — первый официальный стандарт\n- **HTML 3.2 (1997)** — таблицы, апплеты, скрипты\n- **HTML 4.01 (1999)** — улучшенная семантика, CSS поддержка\n- **XHTML 1.0 (2000)** — XML-версия HTML, строгий синтаксис\n- **XHTML 2.0 (заброшен)** — нереалистичные цели, несовместимость\n\n**HTML5 Era:**\n- **2004** — WHATWG начинает работу над Web Applications 1.0\n- **2008** — первый публичный draft HTML5\n- **2014** — HTML5 стал рекомендацией W3C\n- **2016** — HTML 5.1\n- **2017** — HTML 5.2\n- **Настоящее** — HTML Living Standard (постоянно развивается)\n\n**Философия HTML5:** Обратная совместимость — старый код работает. Практичность над чистотой — реальные решения для реальных задач. Четкие правила парсинга — одинаковая обработка во всех браузерах. Открытость и доступность — бесплатные стандарты.\n\n### Новые Семантические Элементы\n\n**Структурные Элементы:**\n\n**header:** Шапка страницы или секции. Содержит навигацию, логотип, заголовки. Может быть несколько на странице. Не путать с head.\n\n**nav:** Блок навигационных ссылок. Для основной навигации сайта. Не для всех групп ссылок. Улучшает доступность — landmark для скринридеров.\n\n**main:** Основное содержимое документа. Только один на странице. Не вкладывается в article, aside, footer, header, nav. Прямой доступ для вспомогательных технологий.\n\n**article:** Независимый, самодостаточный контент. Может быть извлечен и опубликован отдельно. Блог-пост, новость, комментарий, виджет. Может содержать вложенные article.\n\n**section:** Тематическая группировка контента. Должна иметь заголовок. Для логического разделения документа. Не использовать как общий контейнер (для этого div).\n\n**aside:** Контент, косвенно связанный с основным. Сайдбары, врезки, рекламные блоки. Может быть удален без потери смысла основного контента.\n\n**footer:** Подвал страницы или секции. Авторская информация, копирайт, ссылки. Может быть несколько на странице. Не обязательно внизу визуально.\n\n**Контентные Элементы:**\n\n**figure и figcaption:** Самодостаточный контент с подписью. Изображения, диаграммы, код, цитаты. Семантическая связь контента и подписи.\n\n**mark:** Выделение текста для справки. Подсветка поискового запроса. Важный фрагмент в цитате. Визуально — желтый фон.\n\n**time:** Дата, время или продолжительность. Машиночитаемый формат в datetime. Помогает поисковикам и календарям. Улучшает семантику.\n\n**details и summary:** Раскрывающийся виджет disclosure. Summary — заголовок, всегда виден. Нативная функциональность без JavaScript. Атрибут open для раскрытого состояния.\n\n**dialog:** Диалоговое или модальное окно. Методы show() и showModal(). Нативное управление фокусом. Backdrop через CSS ::backdrop.\n\n**Удаленные Элементы:** HTML5 удалил устаревшие, презентационные элементы: font, center, big, strike, frame, frameset, acronym (используйте abbr). Их функции перенесены в CSS.\n\n### Canvas API\n\n**Что такое Canvas:** Элемент для рисования графики через JavaScript. Растровая графика (в отличие от векторного SVG). Динамическое создание изображений. Игры, визуализации, редакторы.\n\n**Базовое Использование:** Создание canvas элемента с размерами. Получение 2D контекста через JavaScript. Рисование примитивов: прямоугольники, круги, линии. Заливка и обводка. Градиенты и паттерны.\n\n**2D Context API:**\n\n**Прямоугольники:** fillRect(x, y, width, height) — заполненный. strokeRect(x, y, width, height) — контур. clearRect(x, y, width, height) — очистка области.\n\n**Пути:** beginPath() — начать новый путь. moveTo(x, y) — переместить перо. lineTo(x, y) — линия к точке. arc(x, y, radius, startAngle, endAngle) — дуга. fill() или stroke() — заполнить или обвести.\n\n**Стили:** fillStyle — цвет заливки. strokeStyle — цвет обводки. lineWidth — толщина линии. createLinearGradient() — линейный градиент. createRadialGradient() — радиальный градиент.\n\n**Текст:** fillText(text, x, y) — заполненный текст. strokeText(text, x, y) — контур текста. font — стиль шрифта. textAlign — выравнивание.\n\n**Изображения:** drawImage(image, x, y) — рисование изображения. Поддержка масштабирования и обрезки. Можно рисовать другие canvas, video.\n\n**Трансформации:** translate(x, y) — сдвиг. rotate(angle) — поворот. scale(x, y) — масштабирование. save() и restore() — сохранение/восстановление состояния.\n\n**Композиция:** globalCompositeOperation — режимы наложения. globalAlpha — прозрачность.\n\n**Анимация:** Очистка canvas. Рисование кадра. requestAnimationFrame() для плавности. Управление состоянием объектов.\n\n**WebGL Context:** 3D графика на GPU. Низкоуровневый API. Библиотеки: Three.js, Babylon.js. Высокая производительность для игр.\n\n**Доступность Canvas:** Canvas недоступен для скринридеров. Fallback контент внутри тега. Альтернативное текстовое описание. ARIA атрибуты. Для интерактивного контента — дублирование в DOM.\n\n### Аудио и Видео\n\n**Нативная Мультимедиа:** До HTML5 требовались плагины (Flash, QuickTime). HTML5 принес нативную поддержку. Унифицированный API. Доступность и безопасность.\n\n**Элемент Video:**\n\n**Базовый Синтаксис:** src — источник видео. controls — показать элементы управления. autoplay — автовоспроизведение (с ограничениями). loop — зацикливание. muted — без звука. poster — изображение-заглушка. preload — предзагрузка (none, metadata, auto). width, height — размеры.\n\n**Множественные Источники:** source элемент для разных форматов. type атрибут с MIME типом. Браузер выбирает первый поддерживаемый. Fallback контент для старых браузеров.\n\n**Форматы Видео:** MP4 (H.264) — лучшая совместимость, все браузеры. WebM (VP9) — открытый, хорошее сжатие. Ogg (Theora) — устарел, низкая поддержка. Рекомендация: MP4 + WebM.\n\n**Элемент Audio:** Аналогично video, без визуальной части. Те же атрибуты и API. Форматы: MP3 (универсален), WAV (без сжатия), Ogg Vorbis, AAC.\n\n**Media API:**\n\n**Свойства:** currentTime — текущее время воспроизведения. duration — длительность. paused — на паузе или нет. ended — закончилось ли. volume — громкость (0.0 - 1.0). playbackRate — скорость воспроизведения. muted — звук отключен. readyState — состояние готовности.\n\n**Методы:** play() — воспроизведение (возвращает Promise). pause() — пауза. load() — перезагрузка. canPlayType(type) — проверка поддержки формата.\n\n**События:** play, pause, ended — управление воспроизведением. timeupdate — обновление времени. volumechange — изменение громкости. loadedmetadata — метаданные загружены. loadeddata — данные загружены. error — ошибка загрузки. canplay — можно начать воспроизведение. seeking, seeked — перемотка.\n\n**Треки и Субтитры:** track элемент для текстовых треков. WebVTT формат. kind: subtitles, captions, descriptions, chapters. srclang — язык. label — название. default — по умолчанию.\n\n**Кастомные Плееры:** Скрытие стандартных контролов. Создание своего UI. Привязка к Media API. Полный контроль над дизайном и функциональностью.\n\n### Улучшенные Формы HTML5\n\n**Новые Типы Input:**\n\n**email:** Валидация email адреса. Специальная клавиатура на мобильных. Атрибут multiple для нескольких адресов.\n\n**url:** Валидация URL. Клавиатура с / и .com.\n\n**tel:** Поле для телефона. Цифровая клавиатура на мобильных. Нет автоматической валидации (форматы различны).\n\n**number:** Числовое поле. Кнопки увеличения/уменьшения. Атрибуты min, max, step. Валидация диапазона.\n\n**range:** Слайдер для выбора числа. Атрибуты min, max, step, value. Визуальный выбор значения.\n\n**date:** Выбор даты через календарь. Нативный UI в поддерживающих браузерах. Формат YYYY-MM-DD.\n\n**time:** Выбор времени. Формат HH:MM или HH:MM:SS.\n\n**datetime-local:** Дата и время без часового пояса. Формат YYYY-MM-DDTHH:MM.\n\n**month:** Выбор месяца и года. Формат YYYY-MM.\n\n**week:** Выбор недели года. Формат YYYY-Www.\n\n**color:** Выбор цвета через палитру. Значение в hex формате #RRGGBB.\n\n**search:** Поле поиска. Кнопка очистки. Семантическое значение.\n\n**Новые Атрибуты:**\n\n**placeholder:** Подсказка внутри поля. Исчезает при вводе. НЕ заменяет label.\n\n**autofocus:** Автоматический фокус при загрузке. Только один на странице. Осторожно с UX.\n\n**autocomplete:** Управление автозаполнением. Значения: on, off, токены (name, email, tel и др.). Ускоряет заполнение форм.\n\n**required:** Обязательное поле. Встроенная валидация браузера. Блокирует отправку при пустом поле.\n\n**pattern:** Регулярное выражение для валидации. Кастомные правила ввода. Сообщение об ошибке через title.\n\n**min, max:** Минимальное и максимальное значение. Для number, date, time и др. Валидация диапазона.\n\n**step:** Шаг изменения значения. Для number, range. Определяет допустимые значения.\n\n**minlength, maxlength:** Ограничение длины текста. minlength — для валидации. maxlength — жесткое ограничение ввода.\n\n**multiple:** Множественный выбор. Для email (несколько адресов). Для file (несколько файлов). Для select.\n\n**list:** Связь с datalist. Автодополнение с предложениями. ID элемента datalist.\n\n**Элемент Datalist:** Список предложенных значений. Работает как автодополнение. Пользователь может ввести свое. Связь через атрибут list.\n\n**Элемент Output:** Результат вычислений. Семантически правильный для выводимых данных. Атрибут for — связь с элементами вычисления.\n\n**Валидация Форм:**\n\n**Встроенная Валидация:** Браузер проверяет перед отправкой. Основано на атрибутах: required, type, pattern, min, max. Автоматические сообщения об ошибках. Можно отключить через novalidate.\n\n**Псевдоклассы:** :valid — поле прошло валидацию. :invalid — поле содержит ошибку. :required — обязательное поле. :optional — необязательное. :in-range, :out-of-range — для числовых полей.\n\n**Constraint Validation API:** setCustomValidity(message) — кастомное сообщение. checkValidity() — проверка валидности. reportValidity() — показать сообщения. validity — объект с деталями ошибки. validationMessage — текст сообщения об ошибке.\n\n### Web Storage API\n\n**До HTML5:** Только cookies для хранения. Ограничение 4 КБ. Отправляются с каждым запросом. Неудобный API.\n\n**localStorage:** Постоянное хранилище в браузере. Данные не удаляются при закрытии. Лимит ~5-10 МБ. Синхронный API. Только строки (сериализуйте объекты).\n\n**Методы localStorage:** setItem(key, value) — сохранить. getItem(key) — получить. removeItem(key) — удалить. clear() — очистить все. key(index) — получить ключ по индексу. length — количество элементов.\n\n**sessionStorage:** Хранилище на время сессии вкладки. Удаляется при закрытии вкладки. Тот же API что у localStorage. Изолировано между вкладками. Лимит ~5-10 МБ.\n\n**Использование:** Сохранение настроек пользователя. Кеширование данных. Сохранение состояния приложения. Черновики форм. Токены аутентификации (с осторожностью).\n\n**Сериализация:** Storage хранит только строки. JSON.stringify() для сохранения объектов. JSON.parse() для восстановления. Обработка ошибок парсинга.\n\n**События Storage:** Событие storage при изменении в другой вкладке. Синхронизация между вкладками. Свойства: key, oldValue, newValue, url.\n\n**Безопасность:** Storage доступен JavaScript. XSS уязвимости опасны. Не храните чувствительные данные. Шифруйте важную информацию. Same-origin policy защищает.\n\n**Альтернативы:** IndexedDB — для больших объемов данных. Cache API — для офлайн кеширования. Cookies — для данных на сервере.\n\n### Геолокация API\n\n**Geolocation API:** Определение местоположения пользователя. Требует разрешения пользователя. Работает через GPS, Wi-Fi, IP. Координаты широты и долготы.\n\n**Методы:**\n\n**getCurrentPosition(success, error, options):** Однократное получение позиции. success callback с координатами. error callback при ошибке. options — настройки точности.\n\n**watchPosition(success, error, options):** Отслеживание изменений позиции. Вызов callback при перемещении. Возвращает ID для остановки. clearWatch(id) — остановить отслеживание.\n\n**Position Object:** coords.latitude — широта. coords.longitude — долгота. coords.accuracy — точность в метрах. coords.altitude — высота над уровнем моря. coords.speed — скорость. timestamp — время получения.\n\n**Options:** enableHighAccuracy — высокая точность (GPS). timeout — максимальное время ожидания. maximumAge — максимальный возраст кешированных данных.\n\n**Обработка Ошибок:** PERMISSION_DENIED — пользователь отказал. POSITION_UNAVAILABLE — невозможно определить. TIMEOUT — превышено время ожидания.\n\n**Использование:** Карты и навигация. Локальный поиск. Персонализация контента. Доставка и логистика. Геотаргетинг рекламы.\n\n**Приватность:** Всегда требует разрешения. Пользователь контролирует доступ. HTTPS обязателен для геолокации. Объясняйте зачем нужны данные.\n\n### Drag and Drop API\n\n**Нативное Перетаскивание:** HTML5 API для drag and drop. Без внешних библиотек. Работает с файлами и элементами. Кроссбраузерная поддержка.\n\n**Перетаскиваемые Элементы:** Атрибут draggable=\"true\". По умолчанию: изображения, ссылки, выделенный текст. Любой элемент можно сделать draggable.\n\n**События Перетаскивания:**\n\n**На Перетаскиваемом:**\n- **dragstart** — начало перетаскивания\n- **drag** — во время перетаскивания\n- **dragend** — конец перетаскивания\n\n**На Целевом:**\n- **dragenter** — вход в зону сброса\n- **dragover** — перемещение над зоной\n- **dragleave** — выход из зоны\n- **drop** — сброс элемента\n\n**DataTransfer Object:** Передача данных при перетаскивании. setData(format, data) — установить данные. getData(format) — получить данные. effectAllowed — разрешенные операции (copy, move, link). dropEffect — эффект сброса. files — перетаскиваемые файлы.\n\n**Основной Паттерн:** dragstart — установка данных. dragover — preventDefault() для разрешения drop. drop — получение данных и обработка. Визуальная обратная связь через CSS.\n\n**Перетаскивание Файлов:** Событие drop на зоне. dataTransfer.files — FileList объект. Обработка загрузки через FileReader. Валидация типов и размера.\n\n**Использование:** Сортировка списков. Загрузка файлов. Drag and drop интерфейсы. Канбан доски. Конструкторы.\n\n### File API\n\n**Работа с Файлами:** Доступ к файлам с устройства. Чтение содержимого. Информация о файлах. Без отправки на сервер.\n\n**File Input:** <input type=\"file\">. files свойство — FileList. multiple атрибут — несколько файлов. accept — ограничение типов.\n\n**File Object:** Наследует Blob. name — имя файла. size — размер в байтах. type — MIME тип. lastModified — дата изменения.\n\n**FileReader API:** Чтение содержимого файлов. Асинхронные операции. События загрузки.\n\n**Методы FileReader:**\n- **readAsText(file)** — как текст\n- **readAsDataURL(file)** — как Data URL (для превью)\n- **readAsArrayBuffer(file)** — как ArrayBuffer\n- **readAsBinaryString(file)** — как бинарная строка\n\n**События FileReader:**\n- **load** — успешное чтение\n- **error** — ошибка чтения\n- **progress** — прогресс чтения\n- **loadstart, loadend** — начало и конец\n\n**Использование:** Превью изображений перед загрузкой. Клиентская валидация файлов. Чтение CSV, JSON файлов. Редакторы текста. Обработка изображений.\n\n**Drag and Drop Файлов:** Комбинация File API и Drag and Drop. dropzone для зоны сброса. dataTransfer.files для получения. Удобный UX загрузки.\n\n### History API\n\n**Управление Историей:** Программное управление браузерной историей. Без перезагрузки страницы. Для Single Page Applications. Работа с URL.\n\n**Методы:**\n\n**pushState(state, title, url):** Добавляет запись в историю. state — объект состояния. title — заголовок (игнорируется браузерами). url — новый URL (опционально).\n\n**replaceState(state, title, url):** Заменяет текущую запись. Те же параметры. Не создает новую запись.\n\n**back(), forward(), go(n):** Навигация по истории. back() — назад. forward() — вперед. go(n) — на n шагов (отрицательные назад).\n\n**Событие popstate:** Срабатывает при навигации. Кнопки назад/вперед. pushState/replaceState НЕ вызывают. event.state — сохраненное состояние.\n\n**Использование в SPA:** Изменение URL без перезагрузки. Сохранение состояния приложения. Работа кнопок браузера. Букмаркинг состояний. SEO-дружественные URL.\n\n**Паттерн Использования:** Перехват кликов по ссылкам. preventDefault() на навигации. pushState() с новым URL. Загрузка контента через AJAX. Обновление DOM. Обработка popstate для кнопок браузера.\n\n### Web Workers\n\n**Многопоточность в Браузере:** JavaScript однопоточный. Тяжелые вычисления блокируют UI. Web Workers — фоновые потоки. Не блокируют главный поток.\n\n**Создание Worker:** new Worker('worker.js'). Отдельный JavaScript файл. Изолированный контекст выполнения. Нет доступа к DOM.\n\n**Коммуникация:**\n\n**Из Main Thread:** worker.postMessage(data) — отправка. worker.onmessage — получение. worker.onerror — обработка ошибок. worker.terminate() — остановка.\n\n**Из Worker:** postMessage(data) — отправка. onmessage — получение. importScripts() — загрузка скриптов. close() — самоостановка.\n\n**Передача Данных:** Структурированное клонирование. Копирование данных (медленно для больших объемов). Transferable Objects — передача владения (быстро). ArrayBuffer можно передавать.\n\n**Типы Workers:**\n\n**Dedicated Workers:** Привязаны к создавшему скрипту. Один владелец. Стандартный тип.\n\n**Shared Workers:** Доступны из нескольких скриптов. Общий контекст. Сложнее в использовании.\n\n**Service Workers:** Прокси между приложением и сетью. Офлайн функциональность. Push уведомления. Background sync.\n\n**Использование:** Обработка больших данных. Сложные вычисления. Парсинг файлов. Криптография. Обработка изображений. Без блокировки UI.\n\n**Ограничения:** Нет доступа к DOM. Нет window, document. Ограниченный API браузера. Коммуникация только через messages.\n\n### Offline и Application Cache (устарел)\n\n**Application Cache:** Первая попытка офлайн приложений. Manifest файл. DEPRECATED — не используйте. Множество проблем и ограничений.\n\n**Почему Устарел:** Сложный и непредсказуемый. Проблемы с обновлением. Кеширует даже с ошибками. Нет гибкого контроля.\n\n**Замена — Service Workers:** Полный контроль над кешированием. Программное управление запросами. Стратегии кеширования. Офлайн-первый подход. Background sync. Push уведомления.\n\n### IndexedDB\n\n**Клиентская База Данных:** NoSQL база в браузере. Хранение больших объемов структурированных данных. Асинхронный API. Индексирование для быстрого поиска.\n\n**Основные Концепции:**\n\n**База Данных:** Контейнер для хранилищ. Версионирование схемы. Несколько баз на origin.\n\n**Object Store:** Аналог таблицы. Хранит объекты. Ключ-значение структура. Может иметь индексы.\n\n**Index:** Индекс по свойству объекта. Ускоряет поиск. Может быть уникальным или нет.\n\n**Transaction:** Атомарные операции. Readonly или readwrite. Автоматический rollback при ошибке.\n\n**Cursor:** Итерация по объектам. Фильтрация и сортировка.\n\n**Основные Операции:**\n\n**Открытие БД:** indexedDB.open(name, version). Событие upgradedneeded для миграций. Создание object stores.\n\n**Добавление Данных:** transaction.objectStore(). add() или put(). Автоматическое коммит.\n\n**Чтение:** get(key) — по ключу. getAll() — все объекты. Cursor для итерации.\n\n**Обновление:** put() с существующим ключом. Перезапись данных.\n\n**Удаление:** delete(key). clear() — все объекты.\n\n**Использование:** Офлайн данные приложений. Кеш больших наборов данных. Синхронизация с сервером. Progressive Web Apps. Избегание частых запросов.\n\n**Сравнение с localStorage:** localStorage — до 10 МБ, синхронный, только строки. IndexedDB — до сотен МБ, асинхронный, структурированные данные. localStorage — простой, IndexedDB — мощный.\n\n### WebSockets\n\n**Постоянное Соединение:** Двусторонняя коммуникация. Реальное время. Без polling. Работает поверх TCP.\n\n**Создание Подключения:** new WebSocket('ws://example.com'). wss:// для защищенного соединения. Событие open при подключении.\n\n**События:**\n- **open** — соединение установлено\n- **message** — получено сообщение\n- **error** — ошибка\n- **close** — соединение закрыто\n\n**Методы:**\n- **send(data)** — отправка данных (строка, Blob, ArrayBuffer)\n- **close()** — закрытие соединения\n\n**Свойства:**\n- **readyState** — состояние (CONNECTING, OPEN, CLOSING, CLOSED)\n- **bufferedAmount** — количество данных в очереди\n\n**Использование:** Чаты в реальном времени. Онлайн игры. Live обновления. Коллаборативное редактирование. Финансовые тикеры. Уведомления.\n\n**Альтернативы:** Server-Sent Events — однонаправленные. Long polling — устаревший подход. HTTP/2 Server Push.\n\n### Новые JavaScript API\n\n**Intersection Observer:** Отслеживание видимости элементов. Ленивая загрузка изображений. Бесконечная прокрутка. Аналитика видимости. Лучше чем scroll события.\n\n**Mutation Observer:** Отслеживание изменений DOM. Добавление/удаление элементов. Изменение атрибутов. Изменение текста. Лучше чем deprecated Mutation Events.\n\n**Resize Observer:** Отслеживание изменений размера элементов. Адаптивные компоненты. Лучше чем window.resize.\n\n**Performance API:** Измерение производительности. Navigation Timing. Resource Timing. User Timing. Mark и Measure для профилирования.\n\n**Fetch API:** Современная замена XMLHttpRequest. Promise-based. Чище и мощнее. Работа с Response и Request объектами.\n\n**Notifications API:** Системные уведомления. Требует разрешения. Работает вне браузера. Комбинация с Service Workers.\n\n**Vibration API:** Вибрация на мобильных. navigator.vibrate(pattern). Тактильная обратная связь.\n\n### Лучшие Практики HTML5\n\n1. Используйте семантические элементы вместо div.\n2. Один main, header, footer на странице.\n3. DOCTYPE html — простой и достаточный.\n4. Валидный HTML5 код.\n5. Прогрессивное улучшение — работа без JS.\n6. Feature detection вместо browser detection.\n7. Полифиллы для старых браузеров.\n8. Доступность — ARIA где необходимо.\n9. Производительность — ленивая загрузка, оптимизация.\n10. Безопасность — валидация на сервере.\n11. Мобильная адаптивность.\n12. Офлайн функциональность через Service Workers.\n13. Web Storage с осторожностью к безопасности.\n14. Canvas fallback контент.\n15. Тестирование в разных браузерах.\n\n### Совместимость и Поддержка\n\n**Проверка Поддержки:** caniuse.com — таблицы совместимости. Modernizr — feature detection библиотека. @supports в CSS. JavaScript проверки API.\n\n**Полифиллы:** Эмуляция новых API в старых браузерах. html5shiv — для IE8. Polyfill.io — автоматический набор. Внимание к размеру бандла.\n\n**Прогрессивное Улучшение:** Базовая функциональность для всех. Улучшения для современных браузеров. Graceful degradation. Никто не остается без контента.\n\n**Вечнозеленые Браузеры:** Современные браузеры автообновляются. Chrome, Firefox, Edge, Safari. Поддержка последних стандартов. Фокус на актуальные версии.\n\n### Заключение\n\nHTML5 революционизировал веб-разработку, предоставив мощные инструменты для создания современных веб-приложений. Семантические элементы улучшили структуру и доступность, мультимедиа API устранили зависимость от плагинов, JavaScript API открыли новые возможности, хранилище и офлайн функции приблизили веб к нативным приложениям. HTML5 — это живой стандарт, постоянно развивающийся, добавляющий новые возможности и совершенствующий существующие. Освоение HTML5 — обязательное условие для современного фронтенд-разработчика, открывающее путь к созданию богатых, интерактивных, доступных веб-приложений.",
  
  "points": [
    "История и эволюция от HTML 1.0 до HTML5",
    "Семантические элементы: header, nav, main, article, section, aside, footer",
    "Контентные элементы: figure, mark, time, details, dialog",
    "Canvas API для 2D графики и анимации",
    "WebGL для 3D графики",
    "Нативные audio и video элементы",
    "Media API для управления воспроизведением",
    "Новые типы input: email, url, tel, number, range, date, color",
    "Новые атрибуты форм: placeholder, autofocus, required, pattern",
    "Datalist для автодополнения",
    "Встроенная валидация форм",
    "Web Storage: localStorage и sessionStorage",
    "Geolocation API для определения местоположения",
    "Drag and Drop API",
    "File API для работы с файлами",
    "History API для управления историей браузера",
    "Web Workers для многопоточности",
    "IndexedDB для клиентской базы данных",
    "WebSockets для реального времени",
    "Новые JavaScript API: Intersection Observer, Mutation Observer",
    "Offline возможности и Service Workers",
    "Совместимость и полифиллы",
    "Прогрессивное улучшение",
    "Лучшие практики HTML5"
  ],
  
  "lesson": {
    "slug": "html-best-practices",
    "title": "Лучшие Практики HTML"
  }
}