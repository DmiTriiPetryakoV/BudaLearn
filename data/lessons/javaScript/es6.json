{
  "slug": "es6-features",
  "title": "Современный JavaScript (ES6+)",
  "description": "Изучите современные возможности JavaScript: стрелочные функции, деструктуризацию, шаблонные строки, модули и другие ES6+ фичи.",
  "difficulty": "intermediate",
  "duration": 50,
    "time":14,
  "theory": "## Введение в ES6+\n\nES6 (ECMAScript 2015) — это масштабное обновление JavaScript, добавившее множество новых возможностей в язык. Последующие версии (ES7, ES8, ES9 и т.д.) продолжают развивать язык, делая его более выразительным и удобным.\n\n## Переменные: let и const\n\n### Замена устаревшему var\n```javascript\n// let — для изменяемых значений\nlet counter = 0;\ncounter = 1; // Можно изменить\n\n// const — для констант\nconst PI = 3.14159;\n// PI = 3.14; // Ошибка! Нельзя переопределять\n\n// const для объектов\nconst user = { name: 'Анна' };\nuser.name = 'Мария'; // Можно изменять свойства\n// user = {}; // Ошибка! Нельзя переопределять ссылку\n```\n\n### Блочная область видимости\n```javascript\nif (true) {\n    let blockScoped = 'видна только в блоке';\n    const alsoBlockScoped = 'тоже только в блоке';\n}\n// console.log(blockScoped); // Ошибка!\n```\n\n## Стрелочные функции\n\n### Синтаксис\n```javascript\n// Обычная функция\nfunction add(a, b) {\n    return a + b;\n}\n\n// Стрелочная функция\nconst add = (a, b) => {\n    return a + b;\n};\n\n// Сокращенный синтаксис\nconst multiply = (a, b) => a * b;\n\n// Один параметр — без скобок\nconst square = x => x * x;\n\n// Без параметров\nconst sayHello = () => 'Hello!';\n```\n\n### Особенности this\nСтрелочные функции не имеют собственного `this`, они используют `this` из внешней области:\n```javascript\nconst timer = {\n    seconds: 0,\n    \n    startRegular() {\n        setInterval(function() {\n            // this === window (или undefined в strict mode)\n            this.seconds++; // Не работает!\n        }, 1000);\n    },\n    \n    startArrow() {\n        setInterval(() => {\n            // this === timer (наследуется)\n            this.seconds++; // Работает!\n        }, 1000);\n    }\n};\n```\n\n## Шаблонные строки (Template Literals)\n\n### Многострочные строки\n```javascript\nconst message = `Это\nмногострочная\nстрока`;\n```\n\n### Интерполяция переменных\n```javascript\nconst name = 'Анна';\nconst age = 25;\n\nconst greeting = `Привет, ${name}!\nТебе ${age} лет.`;\nconsole.log(greeting);\n```\n\n### Выражения в шаблонах\n```javascript\nconst a = 5;\nconst b = 10;\n\nconsole.log(`Сумма: ${a + b}`); // Сумма: 15\nconsole.log(`Это ${age >= 18 ? 'взрослый' : 'ребенок'}`);\n```\n\n## Деструктуризация\n\n### Деструктуризация объектов\n```javascript\nconst user = {\n    name: 'Анна',\n    age: 25,\n    email: 'anna@example.com',\n    address: {\n        city: 'Москва',\n        street: 'Ленина'\n    }\n};\n\n// Извлечение свойств\nconst { name, age } = user;\nconsole.log(name, age); // Анна 25\n\n// Переименование\nconst { name: userName, age: userAge } = user;\n\n// Значения по умолчанию\nconst { phone = 'нет' } = user;\n\n// Вложенная деструктуризация\nconst { address: { city } } = user;\nconsole.log(city); // Москва\n\n// В параметрах функции\nfunction printUser({ name, age }) {\n    console.log(`${name}, ${age} лет`);\n}\n```\n\n### Деструктуризация массивов\n```javascript\nconst numbers = [1, 2, 3, 4, 5];\n\nconst [first, second] = numbers;\nconsole.log(first, second); // 1 2\n\n// Пропуск элементов\nconst [,, third] = numbers; // third = 3\n\n// Остаточные элементы\nconst [head, ...tail] = numbers; // tail = [2, 3, 4, 5]\n\n// Обмен значений\nlet a = 1;\nlet b = 2;\n[a, b] = [b, a]; // Теперь a=2, b=1\n```\n\n## Операторы spread и rest\n\n### Spread оператор (...)\n```javascript\n// Копирование массива\nconst original = [1, 2, 3];\nconst copy = [...original];\n\n// Объединение массивов\nconst arr1 = [1, 2];\nconst arr2 = [3, 4];\nconst combined = [...arr1, ...arr2]; // [1, 2, 3, 4]\n\n// Копирование объекта\nconst obj1 = { a: 1, b: 2 };\nconst obj2 = { ...obj1, c: 3 }; // { a: 1, b: 2, c: 3 }\n\n// Перезапись свойств\nconst updated = { ...obj1, b: 999 }; // { a: 1, b: 999 }\n\n// В вызовах функций\nconst numbers = [1, 2, 3];\nconsole.log(Math.max(...numbers)); // 3\n```\n\n### Rest оператор\n```javascript\n// Сбор оставшихся аргументов\nfunction sum(...numbers) {\n    return numbers.reduce((total, num) => total + num, 0);\n}\nsum(1, 2, 3, 4); // 10\n\n// В деструктуризации\nconst [first, ...rest] = [1, 2, 3, 4]; // rest = [2, 3, 4]\nconst { a, ...others } = { a: 1, b: 2, c: 3 }; // others = { b: 2, c: 3 }\n```\n\n## Параметры по умолчанию\n\n```javascript\nfunction greet(name = 'Гость') {\n    return `Привет, ${name}!`;\n}\n\ngreet(); // Привет, Гость!\ngreet('Анна'); // Привет, Анна!\n\n// С вычисляемым значением\nfunction createUser(name, id = Date.now()) {\n    return { name, id };\n}\n\n// С использованием других параметров\nfunction createPoint(x = 0, y = x * 2) {\n    return { x, y };\n}\n```\n\n## Улучшенный синтаксис объектов\n\n### Сокращенная запись свойств\n```javascript\nconst name = 'Анна';\nconst age = 25;\n\n// Старый синтаксис\nconst user1 = {\n    name: name,\n    age: age,\n    greet: function() {\n        return `Привет, ${this.name}`;\n    }\n};\n\n// Новый синтаксис\nconst user2 = {\n    name, // автоматически: name: name\n    age,  // автоматически: age: age\n    greet() { // метод без function\n        return `Привет, ${this.name}`;\n    }\n};\n```\n\n### Вычисляемые имена свойств\n```javascript\nconst prefix = 'user_';\nconst id = 123;\n\nconst obj = {\n    [prefix + id]: 'Анна',\n    [`${prefix}name`]: 'Мария',\n    ['normal' + 'Property']: 'значение'\n};\n\nconsole.log(obj.user_123); // Анна\n```\n\n## Классы\n\n### Базовый синтаксис\n```javascript\nclass Person {\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    // Метод экземпляра\n    greet() {\n        return `Привет, я ${this.name}`;\n    }\n    \n    // Статический метод\n    static compare(person1, person2) {\n        return person1.age - person2.age;\n    }\n}\n\nconst anna = new Person('Анна', 25);\nconsole.log(anna.greet()); // Привет, я Анна\n\n// Наследование\nclass Employee extends Person {\n    constructor(name, age, position) {\n        super(name, age); // вызов родительского конструктора\n        this.position = position;\n    }\n    \n    work() {\n        return `${this.name} работает как ${this.position}`;\n    }\n}\n\nconst employee = new Employee('Иван', 30, 'Разработчик');\n```\n\n### Геттеры и сеттеры\n```javascript\nclass User {\n    constructor(firstName, lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n    }\n    \n    get fullName() {\n        return `${this.firstName} ${this.lastName}`;\n    }\n    \n    set fullName(value) {\n        const [firstName, lastName] = value.split(' ');\n        this.firstName = firstName;\n        this.lastName = lastName || '';\n    }\n}\n\nconst user = new User('Анна', 'Иванова');\nconsole.log(user.fullName); // Анна Иванова\nuser.fullName = 'Мария Петрова';\nconsole.log(user.firstName); // Мария\n```\n\n## Модули ES6\n\n### Экспорт\n```javascript\n// Именованный экспорт\nexport const PI = 3.14159;\nexport function circleArea(radius) {\n    return PI * radius * radius;\n}\nexport class Calculator {\n    // ...\n}\n\n// Или одним объектом\nexport { PI, circleArea, Calculator };\n\n// Экспорт по умолчанию\nexport default function() {\n    console.log('Default export');\n}\n```\n\n### Импорт\n```javascript\n// Именованный импорт\nimport { PI, circleArea } from './math.js';\n\n// Импорт с переименованием\nimport { PI as piValue } from './math.js';\n\n// Импорт всего модуля\nimport * as MathModule from './math.js';\n\n// Импорт по умолчанию\nimport myFunction from './module.js';\n\n// Комбинированный импорт\nimport defaultExport, { namedExport } from './module.js';\n```\n\n## Итераторы и генераторы\n\n### Итераторы\n```javascript\nconst myIterable = {\n    [Symbol.iterator]() {\n        let step = 0;\n        return {\n            next() {\n                step++;\n                if (step <= 3) {\n                    return { value: step, done: false };\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n};\n\nfor (const value of myIterable) {\n    console.log(value); // 1, 2, 3\n}\n```\n\n### Генераторы\n```javascript\nfunction* numberGenerator() {\n    yield 1;\n    yield 2;\n    yield 3;\n}\n\nconst generator = numberGenerator();\nconsole.log(generator.next().value); // 1\nconsole.log(generator.next().value); // 2\nconsole.log(generator.next().value); // 3\nconsole.log(generator.next().done);  // true\n\n// Бесконечный генератор\nfunction* infiniteSequence() {\n    let i = 0;\n    while (true) {\n        yield i++;\n    }\n}\n```\n\n## Promise и асинхронность\n\n### Promise\n```javascript\nconst fetchData = () => {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            resolve('Данные получены');\n        }, 1000);\n    });\n};\n\nfetchData().then(data => console.log(data));\n```\n\n### Async/Await\n```javascript\nasync function getUserData() {\n    try {\n        const response = await fetch('/api/user');\n        const data = await response.json();\n        return data;\n    } catch (error) {\n        console.error('Ошибка:', error);\n        throw error;\n    }\n}\n```\n\n## Коллекции Map и Set\n\n### Map\n```javascript\nconst map = new Map();\n\nmap.set('name', 'Анна');\nmap.set('age', 25);\n\nconsole.log(map.get('name')); // Анна\nconsole.log(map.size); // 2\nconsole.log(map.has('age')); // true\n\nmap.delete('age');\nmap.clear();\n\n// Итерация\nfor (const [key, value] of map) {\n    console.log(key, value);\n}\n```\n\n### Set\n```javascript\nconst set = new Set([1, 2, 3, 3, 4]); // Удаляет дубликаты\n\nset.add(5);\nset.delete(3);\nconsole.log(set.has(2)); // true\nconsole.log(set.size); // 3\n\n// Итерация\nfor (const value of set) {\n    console.log(value);\n}\n```\n\n## Символы (Symbols)\n\n```javascript\nconst id = Symbol('id');\nconst user = {\n    name: 'Анна',\n    [id]: 123 // Скрытое свойство\n};\n\nconsole.log(user[id]); // 123\nconsole.log(Object.keys(user)); // ['name'] - символ не показывается\n\n// Глобальные символы\nconst globalId = Symbol.for('app.id');\nconst sameId = Symbol.for('app.id');\nconsole.log(globalId === sameId); // true\n```\n\n## Опциональная цепочка (Optional Chaining)\n\n```javascript\nconst user = {\n    profile: {\n        name: 'Анна',\n        address: {\n            city: 'Москва'\n        }\n    }\n};\n\n// Старый способ\nconst city = user && user.profile && user.profile.address && user.profile.address.city;\n\n// Новый способ\nconst cityNew = user?.profile?.address?.city; // 'Москва'\nconst zipCode = user?.profile?.address?.zipCode; // undefined (без ошибки)\n\n// С функциями и методами\nuser?.profile?.update?.(); // Если метод существует\n\n// С массивами\nconst firstItem = user?.orders?.[0];\n```\n\n## Оператор нулевого слияния (Nullish Coalescing)\n\n```javascript\nconst value = null ?? 'default'; // 'default'\nconst value2 = undefined ?? 'default'; // 'default'\nconst value3 = 0 ?? 'default'; // 0 (не null/undefined)\nconst value4 = '' ?? 'default'; // '' (не null/undefined)\nconst value5 = false ?? 'default'; // false (не null/undefined)\n\n// Отличие от ||\nconst withOr = 0 || 'default'; // 'default' (0 - falsy)\nconst withNullish = 0 ?? 'default'; // 0\n```\n\n## Динамический импорт\n\n```javascript\n// Импорт по требованию\nasync function loadModule() {\n    const module = await import('./module.js');\n    module.doSomething();\n}\n\n// Условный импорт\nif (userNeedsFeature) {\n    import('./feature.js').then(module => {\n        module.initialize();\n    });\n}\n```\n\n## BigInt\n\n```javascript\nconst bigNumber = 9007199254740991n; // Превышает Number.MAX_SAFE_INTEGER\nconst anotherBigInt = BigInt('12345678901234567890');\n\nconsole.log(bigNumber + 1n); // 9007199254740992n\nconsole.log(typeof bigNumber); // 'bigint'\n```\n\n## Методы массивов ES6+\n\n```javascript\n// Array.from()\nconst arrayLike = { length: 3, 0: 'a', 1: 'b', 2: 'c' };\nconst arr = Array.from(arrayLike); // ['a', 'b', 'c']\n\n// Array.of()\nArray.of(1, 2, 3); // [1, 2, 3]\n\n// .find() и .findIndex()\n[1, 5, 10, 15].find(x => x > 8); // 10\n[1, 5, 10, 15].findIndex(x => x > 8); // 2\n\n// .includes()\n[1, 2, 3].includes(2); // true\n\n// .flat() и .flatMap()\n[[1, 2], [3, 4]].flat(); // [1, 2, 3, 4]\n[1, 2, 3].flatMap(x => [x, x * 2]); // [1, 2, 2, 4, 3, 6]\n```\n\n## Методы строк ES6+\n\n```javascript\n// .startsWith() и .endsWith()\n'Hello World'.startsWith('Hello'); // true\n'Hello World'.endsWith('World'); // true\n\n// .includes()\n'Hello World'.includes('lo'); // true\n\n// .repeat()\n'ha'.repeat(3); // 'hahaha'\n\n// .padStart() и .padEnd()\n'5'.padStart(3, '0'); // '005'\n'hi'.padEnd(5, '!'); // 'hi!!!'\n```\n\n## Лучшие практики ES6+\n\n1. **Используйте const по умолчанию**, let только когда нужно переопределять\n2. **Предпочитайте стрелочные функции** для коллбэков\n3. **Используйте шаблонные строки** вместо конкатенации\n4. **Применяйте деструктуризацию** для чистого кода\n5. **Используйте spread/rest операторы** для работы с массивами и объектами\n6. **Экспортируйте по одному** — именованный экспорт лучше default\n7. **Используйте классы** для ООП, но не злоупотребляйте наследованием\n8. **Применяйте современные методы массивов и строк**\n9. **Используйте опциональную цепочку** для безопасного доступа\n10. **Отдавайте предпочтение async/await** над цепочками .then()\n\n## Заключение\n\nES6+ существенно улучшил JavaScript, сделав его более выразительным, безопасным и удобным для разработки. Современные возможности языка позволяют писать более чистый, поддерживаемый и эффективный код.\n\nКлючевые преимущества ES6+:\n- Улучшенный синтаксис и читаемость\n- Лучшие инструменты для работы с асинхронностью\n- Более безопасные конструкции\n- Поддержка модульности\n- Современные структуры данных\n\nОсвоение этих возможностей критически важно для современного JavaScript-разработчика и позволяет создавать более качественные приложения.",
  
  "points": [
    "let и const с блочной областью видимости",
    "Стрелочные функции и особенности this",
    "Шаблонные строки и интерполяция",
    "Деструктуризация объектов и массивов",
    "Операторы spread и rest",
    "Параметры функций по умолчанию",
    "Улучшенный синтаксис объектов",
    "Классы, наследование и статические методы",
    "Модули ES6: экспорт и импорт",
    "Promise, async/await",
    "Коллекции Map и Set",
    "Опциональная цепочка и нулевое слияние"
  ],
  
  "lesson": {
    "slug": "testing",
    "title": "Тестирование JavaScript кода"
  }
}