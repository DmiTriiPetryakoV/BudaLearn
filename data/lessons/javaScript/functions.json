{
  "slug": "functions",
  "title": "Функции в JavaScript",
  "description": "Изучите функции — фундаментальные строительные блоки JavaScript для организации кода, повторного использования и управления областью видимости.",
  "difficulty": "beginner",
  "duration": 35,
    "time":12,
  "theory": "# Функции в JavaScript\n\n## Введение в функции\n\nФункции — это один из краеугольных камней JavaScript. Они представляют собой блоки кода, которые можно многократно вызывать с разными аргументами для выполнения определённых задач. Функции служат основным механизмом для организации, структурирования и повторного использования кода.\n\n## Определение функций\n\n### 1. Function Declaration (Объявление функции)\n\nСамый традиционный способ объявления функции с использованием ключевого слова `function`:\n```javascript\nfunction greet(name) {\n    return `Привет, ${name}!`;\n}\n```\n\n**Особенности Function Declaration:**\n- Поднимаются (hoisted) — могут быть вызваны до объявления\n- Имеют имя (обязательно)\n- Создают собственную область видимости\n\n### 2. Function Expression (Функциональное выражение)\n\nФункция, присваиваемая переменной:\n```javascript\nconst greet = function(name) {\n    return `Привет, ${name}!`;\n};\n```\n\n**Особенности Function Expression:**\n- Не поднимаются (нельзя вызвать до присваивания)\n- Могут быть анонимными или именованными\n- Часто используются как callback-функции\n\n### 3. Arrow Functions (Стрелочные функции) (ES6+)\n\nСовременный компактный синтаксис:\n```javascript\nconst greet = (name) => {\n    return `Привет, ${name}!`;\n};\n\n// Сокращённая форма при одном выражении\nconst greet = name => `Привет, ${name}!`;\n```\n\n**Ключевые особенности стрелочных функций:**\n- Не имеют собственного `this` (наследуют из внешней области)\n- Не имеют объекта `arguments`\n- Не могут быть конструкторами (нельзя использовать с `new`)\n- Более короткий синтаксис\n\n### 4. Immediately Invoked Function Expression (IIFE)\n\nФункция, вызываемая немедленно после объявления:\n```javascript\n(function() {\n    console.log('Функция выполняется сразу!');\n})();\n```\n\n**Назначение IIFE:**\n- Создание изолированной области видимости\n- Защита от загрязнения глобального пространства имён\n- Использование в модульных паттернах\n\n## Параметры и аргументы\n\n### Параметры по умолчанию (ES6+)\n```javascript\nfunction greet(name = 'Гость') {\n    return `Привет, ${name}!`;\n}\n```\n\n### Rest parameters (Остаточные параметры)\n```javascript\nfunction sum(...numbers) {\n    return numbers.reduce((total, num) => total + num, 0);\n}\n```\n\n## Возвращаемые значения\n\nФункция может возвращать значение с помощью оператора `return`. Если `return` отсутствует или не указано значение, функция возвращает `undefined`.\n\n## Область видимости (Scope)\n\n### Лексическая область видимости\n\nJavaScript использует лексическую (статическую) область видимости — доступ к переменным определяется их положением в исходном коде.\n\n### Типы областей видимости\n\n1. **Глобальная область видимости** — переменные, объявленные вне функций\n2. **Локальная область видимости** — переменные, объявленные внутри функции\n3. **Блочная область видимости** — переменные, объявленные с `let` и `const` внутри блоков `{}` (ES6+)\n\n### Замыкания (Closures)\n\nЗамыкание — это функция, которая запоминает своё лексическое окружение даже при выполнении вне этого окружения.\n```javascript\nfunction createCounter() {\n    let count = 0;\n    return function() {\n        count++;\n        return count;\n    };\n}\n```\n\n**Применение замыканий:**\n- Создание приватных переменных\n- Фабричные функции\n- Каррирование и частичное применение\n\n## this в функциях\n\nЗначение `this` зависит от контекста вызова функции.\n\n### Правила определения this\n\n1. **Глобальный контекст** — `this` ссылается на глобальный объект (`window` в браузере)\n2. **Вызов метода объекта** — `this` ссылается на объект, которому принадлежит метод\n3. **Конструктор** — `this` ссылается на создаваемый экземпляр\n4. **Явная привязка** — `call()`, `apply()`, `bind()`\n5. **Стрелочные функции** — не имеют собственного `this`, используют внешний контекст\n\n### Методы управления this\n\n- **call()** — вызывает функцию с указанным значением `this` и аргументами\n- **apply()** — аналогично `call()`, но аргументы передаются массивом\n- **bind()** — создаёт новую функцию с привязанным значением `this`\n\n## Функции высшего порядка\n\nФункции, которые принимают другие функции в качестве аргументов или возвращают функции.\n\n### Применение в массивах\n```javascript\nconst numbers = [1, 2, 3, 4];\n\n// map — преобразование каждого элемента\nconst doubled = numbers.map(n => n * 2);\n\n// filter — фильтрация элементов\nconst even = numbers.filter(n => n % 2 === 0);\n\n// reduce — свёртка массива\nconst sum = numbers.reduce((total, n) => total + n, 0);\n```\n\n### Создание функций высшего порядка\n```javascript\nfunction multiplier(factor) {\n    return function(number) {\n        return number * factor;\n    };\n}\n```\n\n## Рекурсия\n\nРекурсия — когда функция вызывает саму себя.\n\n### Базовый случай и рекурсивный случай\n```javascript\nfunction factorial(n) {\n    if (n === 0 || n === 1) { // базовый случай\n        return 1;\n    }\n    return n * factorial(n - 1); // рекурсивный случай\n}\n```\n\n**Важно:** Рекурсивные функции должны иметь условие завершения (базовый случай).\n\n## Асинхронные функции\n\n### Callback функции\n```javascript\nfunction fetchData(callback) {\n    setTimeout(() => {\n        callback('Данные получены');\n    }, 1000);\n}\n```\n\n### Promise\n```javascript\nfunction fetchData() {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            resolve('Данные получены');\n        }, 1000);\n    });\n}\n```\n\n### Async/Await (ES8+)\n```javascript\nasync function getData() {\n    try {\n        const data = await fetchData();\n        return data;\n    } catch (error) {\n        console.error('Ошибка:', error);\n    }\n}\n```\n\n## Функциональное программирование\n\n### Чистые функции\n\nФункции, которые:\n1. Всегда возвращают одинаковый результат для одинаковых аргументов\n2. Не имеют побочных эффектов (не изменяют внешнее состояние)\n\n### Каррирование\n\nПреобразование функции с несколькими аргументами в последовательность функций с одним аргументом.\n\n### Композиция функций\n\nОбъединение нескольких функций в одну.\n\n## Оптимизация и лучшие практики\n\n### Избегание создания функций в циклах\n\n**Плохо:**\n```javascript\nfor (let i = 0; i < 10; i++) {\n    elements[i].onclick = function() {\n        console.log(i); // Создаётся 10 разных функций\n    };\n}\n```\n\n**Хорошо:**\n```javascript\nfunction createHandler(index) {\n    return function() {\n        console.log(index);\n    };\n}\n\nfor (let i = 0; i < 10; i++) {\n    elements[i].onclick = createHandler(i);\n}\n```\n\n### Мемоизация\n\nКэширование результатов вызовов функции для повторного использования.\n\n### Декомпозиция\n\nРазбиение сложных функций на более простые, специализированные функции.\n\n## Заключение\n\nФункции в JavaScript — мощный и гибкий инструмент, который выходит далеко за рамки простого повторного использования кода. Понимание различных способов объявления функций, работы с областью видимости, контекстом `this` и функциональными возможностями является ключом к написанию чистого, эффективного и поддерживаемого кода.\n\nСовременный JavaScript предлагает богатый набор инструментов для работы с функциями — от стрелочных функций и параметров по умолчанию до асинхронных функций и функциональных паттернов программирования. Освоение этих концепций позволяет создавать более выразительный, модульный и эффективный код.\n",
  
  "points": [
    "Способы объявления функций: Declaration, Expression, Arrow",
    "Параметры функций: значения по умолчанию, rest параметры",
    "Область видимости: глобальная, локальная, блочная",
    "Замыкания и их практическое применение",
    "Ключевое слово this и методы его управления",
    "Функции высшего порядка и callback-функции",
    "Рекурсия и её особенности",
    "Асинхронные функции: callback, Promise, async/await",
    "Чистые функции и функциональное программирование",
    "Оптимизация: мемоизация, избегание создания функций в циклах"
  ],
  
  "lesson": {
    "slug": "dom-manipulation",
    "title": "Работа с DOM и событиями"
  }
}