{
  "slug": "dom-manipulation",
  "title": "Работа с DOM и событиями",
  "description": "Изучите Document Object Model (DOM) — программный интерфейс для работы с HTML-документами и обработки событий в браузере.",
  "difficulty": "intermediate",
  "duration": 40,
  "time":13,
  "theory": "# Работа с DOM и событиями в JavaScript\n\n## Введение в DOM\n\n### Что такое DOM?\n\nDOM (Document Object Model) — это программный интерфейс для HTML и XML документов. Он представляет документ в виде древовидной структуры узлов (дерева DOM), где каждый узел является объектом, представляющим часть документа.\n\n### Дерево DOM\n\nDOM организует HTML-документ в иерархическую древовидную структуру:\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Моя страница</title>\n  </head>\n  <body>\n    <h1>Заголовок</h1>\n    <p>Текст параграфа</p>\n  </body>\n</html>\n```\n\n**Соответствующая DOM-структура:**\n- Документ (Document)\n  - Элемент html\n    - Элемент head\n      - Элемент title\n        - Текстовый узел \"Моя страница\"\n    - Элемент body\n      - Элемент h1\n        - Текстовый узел \"Заголовок\"\n      - Элемент p\n        - Текстовый узел \"Текст параграфа\"\n\n## Навигация по DOM\n\n### Глобальный объект document\n\nОбъект `document` представляет всю HTML-страницу и является точкой входа для работы с DOM.\n\n### Основные свойства для навигации\n\n```javascript\n// Корневые элементы\ndocument.documentElement    // <html>\ndocument.body              // <body>\ndocument.head              // <head>\n\n// Работа с дочерними элементами\nelement.children           // коллекция дочерних элементов\nelement.firstElementChild  // первый дочерний элемент\nelement.lastElementChild   // последний дочерний элемент\nelement.previousElementSibling  // предыдущий соседний элемент\nelement.nextElementSibling      // следующий соседний элемент\n\n// Работа с узлами (включая текстовые узлы)\nelement.childNodes         // коллекция всех дочерних узлов\nelement.firstChild         // первый дочерний узел\nelement.lastChild          // последний дочерний узел\nelement.parentNode         // родительский узел\n```\n\n## Поиск элементов в DOM\n\n### Методы поиска\n\n#### 1. Поиск по ID\n```javascript\ndocument.getElementById('elementId');\n```\n\n#### 2. Поиск по селектору CSS\n```javascript\n// Находит первый элемент, соответствующий селектору\ndocument.querySelector('.className');\ndocument.querySelector('#id');\ndocument.querySelector('div.className');\n\n// Находит все элементы, соответствующие селектору\ndocument.querySelectorAll('.className');\ndocument.querySelectorAll('div');\n```\n\n#### 3. Поиск по имени тега\n```javascript\ndocument.getElementsByTagName('div');\n```\n\n#### 4. Поиск по имени класса\n```javascript\ndocument.getElementsByClassName('className');\n```\n\n#### 5. Поиск по имени атрибута\n```javascript\ndocument.getElementsByName('fieldName');\n```\n\n### Различия между методами\n\n- `getElementById()` возвращает один элемент (или null)\n- `querySelector()` возвращает первый найденный элемент (или null)\n- Методы с `Elements` (во множественном числе) возвращают живые коллекции (обновляются при изменении DOM)\n- `querySelectorAll()` возвращает статическую коллекцию (NodeList)\n\n## Создание и изменение элементов\n\n### Создание элементов\n\n```javascript\n// Создание нового элемента\nconst newDiv = document.createElement('div');\nconst newParagraph = document.createElement('p');\n\n// Создание текстового узла\nconst textNode = document.createTextNode('Новый текст');\n\n// Клонирование существующего элемента\nconst clonedElement = existingElement.cloneNode(true); // true — глубокое клонирование\n```\n\n### Изменение содержимого\n\n```javascript\n// innerHTML — работа с HTML как со строкой\nelement.innerHTML = '<span>Новый HTML</span>';\n\n// textContent — работа с текстом\nelement.textContent = 'Новый текст';\n\n// innerText — учитывает стили (медленнее чем textContent)\nelement.innerText = 'Новый текст';\n```\n\n### Добавление элементов в DOM\n\n```javascript\n// append — добавляет элементы или текст в конец\nelement.append(newDiv, 'текст', anotherElement);\n\n// appendChild — добавляет один элемент в конец\nelement.appendChild(newDiv);\n\n// prepend — добавляет элементы или текст в начало\nelement.prepend(newDiv);\n\n// insertBefore — вставляет элемент перед указанным элементом\nparent.insertBefore(newElement, referenceElement);\n\n// insertAdjacentHTML — вставляет HTML в указанную позицию\nelement.insertAdjacentHTML('beforebegin', '<div>Перед</div>');\nelement.insertAdjacentHTML('afterbegin', '<div>В начале</div>');\nelement.insertAdjacentHTML('beforeend', '<div>В конце</div>');\nelement.insertAdjacentHTML('afterend', '<div>После</div>');\n```\n\n### Удаление элементов\n\n```javascript\n// Удаление дочернего элемента\nparent.removeChild(childElement);\n\n// Современный способ\nelement.remove();\n```\n\n### Замена элементов\n\n```javascript\nparent.replaceChild(newElement, oldElement);\n```\n\n## Работа с атрибутами и классами\n\n### Атрибуты\n\n```javascript\n// Получение значения атрибута\nelement.getAttribute('id');\n\n// Установка атрибута\nelement.setAttribute('data-value', '123');\n\n// Проверка наличия атрибута\nelement.hasAttribute('required');\n\n// Удаление атрибута\nelement.removeAttribute('disabled');\n\n// Свойства для стандартных атрибутов\nelement.id = 'newId';\nelement.className = 'class1 class2';\nelement.href = 'https://example.com';\nelement.value = 'текст';\n```\n\n### Классы (classList)\n\n```javascript\n// Добавление класса\nelement.classList.add('active', 'highlight');\n\n// Удаление класса\nelement.classList.remove('inactive');\n\n// Переключение класса\nelement.classList.toggle('active');\n\n// Проверка наличия класса\nelement.classList.contains('active');\n\n// Замена класса\nelement.classList.replace('oldClass', 'newClass');\n```\n\n### Пользовательские атрибуты (data-*)\n\n```javascript\n// HTML: <div data-user-id=\"123\" data-config='{\"color\":\"red\"}'>\n\n// Доступ через dataset\nelement.dataset.userId;      // \"123\"\nelement.dataset.config;      // '{\"color\":\"red\"}'\n\n// Установка значения\nelement.dataset.status = 'active';\n// Добавляет data-status=\"active\"\n```\n\n## Стилизация элементов\n\n### Объект style\n\n```javascript\n// Получение и установка стилей\nelement.style.color = 'red';\nelement.style.backgroundColor = '#f0f0f0';\nelement.style.fontSize = '16px';\nelement.style.marginTop = '10px';\n\n// Получение вычисленных стилей\nconst computedStyle = window.getComputedStyle(element);\nconst color = computedStyle.color;\n```\n\n### Работа с классами CSS\n\n```javascript\n// Добавление CSS класса\nelement.classList.add('highlight');\n\n// Создание и добавление стилей через CSSOM\nconst style = document.createElement('style');\nstyle.textContent = '.highlight { background: yellow; }';\ndocument.head.appendChild(style);\n```\n\n## События (Events)\n\n### Модель событий\n\nСобытия — это действия, происходящие в браузере (клики, нажатия клавиш, загрузка и т.д.), на которые можно реагировать с помощью JavaScript.\n\n### Типы событий\n\n1. **События мыши:** click, dblclick, mousedown, mouseup, mousemove, mouseover, mouseout\n2. **События клавиатуры:** keydown, keyup, keypress\n3. **События формы:** submit, change, input, focus, blur\n4. **События окна:** load, resize, scroll\n5. **События касания:** touchstart, touchmove, touchend\n6. **События медиа:** play, pause, ended\n\n### Добавление обработчиков событий\n\n#### 1. Через свойства\n```javascript\nelement.onclick = function(event) {\n    console.log('Клик!');\n};\n```\n\n#### 2. addEventListener (рекомендуемый способ)\n```javascript\nelement.addEventListener('click', function(event) {\n    console.log('Клик!');\n});\n\n// С передачей параметров\nfunction handleClick(message) {\n    console.log(message);\n}\n\nelement.addEventListener('click', function() {\n    handleClick('Клик!');\n});\n\n// Использование стрелочной функции\nelement.addEventListener('click', (event) => {\n    console.log('Клик!', event.target);\n});\n```\n\n#### 3. HTML атрибут (не рекомендуется)\n```html\n<button onclick=\"handleClick()\">Клик</button>\n```\n\n### Удаление обработчиков событий\n\n```javascript\nfunction handleClick() {\n    console.log('Клик!');\n}\n\nelement.addEventListener('click', handleClick);\n\n// Удаление обработчика\nelement.removeEventListener('click', handleClick);\n```\n\n### Объект события (Event)\n\nПри возникновении события создаётся объект Event, содержащий информацию о событии:\n\n```javascript\nelement.addEventListener('click', function(event) {\n    console.log(event.type);        // \"click\"\n    console.log(event.target);      // элемент, на котором произошло событие\n    console.log(event.currentTarget); // элемент, на котором висит обработчик\n    console.log(event.clientX);    // координата X мыши\n    console.log(event.clientY);    // координата Y мыши\n    console.log(event.key);        // нажатая клавиша (для keyboard events)\n    console.log(event.preventDefault); // метод для отмены стандартного действия\n});\n```\n\n### Всплытие и погружение\n\nСобытия в DOM распространяются в три фазы:\n\n1. **Фаза погружения (capturing)** — от window до целевого элемента\n2. **Целевая фаза (target)** — достижение целевого элемента\n3. **Фаза всплытия (bubbling)** — от целевого элемента до window\n\n```javascript\n// Обработчик на фазе погружения (третий параметр true)\nelement.addEventListener('click', handler, true);\n\n// Обработчик на фазе всплытия (третий параметр false или опущен)\nelement.addEventListener('click', handler, false);\nelement.addEventListener('click', handler); // по умолчанию false\n```\n\n### Остановка распространения события\n\n```javascript\nelement.addEventListener('click', function(event) {\n    event.stopPropagation(); // остановка всплытия\n    event.stopImmediatePropagation(); // остановка всплытия и других обработчиков\n});\n```\n\n### Отмена стандартного поведения\n\n```javascript\n// Для ссылок, форм и т.д.\nelement.addEventListener('click', function(event) {\n    event.preventDefault(); // отмена стандартного действия\n});\n```\n\n### Делегирование событий\n\nВместо добавления обработчиков к множеству элементов, добавляем один обработчик к их общему родителю:\n\n```javascript\ndocument.addEventListener('click', function(event) {\n    if (event.target.matches('.delete-button')) {\n        // Обработка клика на кнопку удаления\n        deleteItem(event.target.dataset.id);\n    }\n});\n```\n\n## Работа с формами\n\n### Доступ к элементам формы\n\n```javascript\nconst form = document.querySelector('form');\n\n// Через коллекцию elements\nconst input = form.elements.username;\nconst email = form.elements.email;\n\n// Получение данных формы\nconst formData = new FormData(form);\nconst data = Object.fromEntries(formData);\n```\n\n### События форм\n\n```javascript\n// При изменении значения\ninput.addEventListener('input', handler);\ninput.addEventListener('change', handler);\n\n// При фокусировке\ninput.addEventListener('focus', handler);\ninput.addEventListener('blur', handler);\n\n// При отправке формы\nform.addEventListener('submit', function(event) {\n    event.preventDefault();\n    // Обработка данных формы\n});\n```\n\n## Асинхронная работа с DOM\n\n### MutationObserver\n\nПозволяет отслеживать изменения в DOM:\n```javascript\nconst observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n        console.log('DOM изменён:', mutation.type);\n    });\n});\n\nobserver.observe(element, {\n    childList: true,\n    attributes: true,\n    characterData: true,\n    subtree: true\n});\n```\n\n## Оптимизация производительности\n\n### Виртуальный DOM\n\nИспользуется в современных фреймворках (React, Vue) для минимизации прямых операций с DOM.\n\n### Batch обновления\n\n```javascript\n// Плохо — множественные перерисовки\nfor (let i = 0; i < 100; i++) {\n    element.textContent = i;\n}\n\n// Хорошо — одна перерисовка\nconst fragment = document.createDocumentFragment();\nfor (let i = 0; i < 100; i++) {\n    const div = document.createElement('div');\n    div.textContent = i;\n    fragment.appendChild(div);\n}\nelement.appendChild(fragment);\n```\n\n### Отложенные обновления\n\n```javascript\n// Использование requestAnimationFrame\nfunction updateElement() {\n    requestAnimationFrame(() => {\n        element.style.transform = `translateX(${position}px)`;\n    });\n}\n```\n\n## Современные API\n\n### Intersection Observer\n\nОтслеживание видимости элементов в области просмотра:\n```javascript\nconst observer = new IntersectionObserver((entries) => {\n    entries.forEach(entry => {\n        if (entry.isIntersecting) {\n            entry.target.classList.add('visible');\n        }\n    });\n});\n\nobserver.observe(element);\n```\n\n### Resize Observer\n\nОтслеживание изменения размеров элементов.\n\n## Лучшие практики\n\n### 1. Кэширование ссылок на элементы\n\n```javascript\n// Хорошо\nconst elements = {\n    button: document.querySelector('.btn'),\n    input: document.querySelector('.input'),\n    container: document.querySelector('.container')\n};\n```\n\n### 2. Использование делегирования событий\n\n### 3. Минимизация операций с DOM\n\n### 4. Использование современных API вместо устаревших методов\n\n### 5. Очистка обработчиков событий при удалении элементов\n\n## Заключение\n\nРабота с DOM и событиями — фундаментальный навык для frontend-разработки. Понимание структуры DOM, методов навигации и манипуляции элементами, а также модели событий позволяет создавать интерактивные и динамические веб-приложения.\n\nСовременный JavaScript предлагает мощные инструменты для эффективной работы с DOM, но важно помнить о производительности и использовать лучшие практики, такие как делегирование событий, батчинг обновлений и очистка ресурсов.\n\nОсвоение этих концепций открывает путь к созданию сложных интерфейсов, работе с современными фреймворками и пониманию принципов реактивного программирования.\n",
  
  "points": [
    "DOM-структура и навигация по дереву элементов",
    "Методы поиска элементов в документе",
    "Создание, изменение и удаление DOM-элементов",
    "Работа с атрибутами, классами и стилями",
    "Модель событий и обработчики",
    "Всплытие и погружение событий",
    "Делегирование событий для производительности",
    "Работа с формами и их элементами",
    "Современные API: MutationObserver, IntersectionObserver",
    "Оптимизация производительности при работе с DOM"
  ],
  
  "lesson": {
    "slug": "async",
    "title": "Асинхронное программирование"
  }
}