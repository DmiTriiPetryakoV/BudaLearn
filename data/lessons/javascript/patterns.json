{
  "slug": "patterns",
  "title": "Паттерны проектирования в JavaScript",
  "description": "Изучите основные паттерны проектирования для создания масштабируемого, поддерживаемого и повторно используемого кода.",
  "difficulty": "advanced",
  "duration": 50,
    "time":16,
  "theory": "## Введение в паттерны проектирования\n\nПаттерны проектирования — это проверенные временем решения типичных проблем, возникающих при проектировании программного обеспечения. Они представляют собой не готовый код, а шаблоны, которые можно адаптировать под конкретные задачи.\n\n## Категории паттернов\n\n### Порождающие паттерны\nОтвечают за создание объектов, скрывая детали их инстанцирования и делая систему независимой от способа создания объектов.\n\n### Структурные паттерны\nОписывают способы компоновки классов и объектов для формирования более крупных структур.\n\n### Поведенческие паттерны\nОпределяют алгоритмы и способы взаимодействия между объектами, распределяя ответственность.\n\n## Порождающие паттерны\n\n### 1. Фабричный метод (Factory Method)\nОпределяет интерфейс для создания объекта, но позволяет подклассам изменять тип создаваемого объекта.\n\n**Назначение:** Создание объектов без указания конкретных классов.\n\n**Применение:** Когда классу заранее неизвестно, объекты каких классов ему нужно создавать.\n\n### 2. Абстрактная фабрика (Abstract Factory)\nПредоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов без указания их конкретных классов.\n\n**Назначение:** Создание целых семейств связанных объектов.\n\n**Применение:** Когда система должна быть независимой от процесса создания объектов и их компоновки.\n\n### 3. Строитель (Builder)\nОтделяет конструирование сложного объекта от его представления, позволяя создавать разные представления с помощью одного и того же процесса конструирования.\n\n**Назначение:** Пошаговое создание сложных объектов.\n\n**Применение:** Когда процесс создания объекта состоит из множества шагов.\n\n### 4. Прототип (Prototype)\nПозволяет создавать новые объекты путем копирования существующих объектов (прототипов).\n\n**Назначение:** Клонирование объектов без привязки к их классам.\n\n**Применение:** Когда создание объекта требует больших затрат ресурсов.\n\n### 5. Одиночка (Singleton)\nГарантирует, что у класса есть только один экземпляр, и предоставляет глобальную точку доступа к этому экземпляру.\n\n**Назначение:** Контроль создания единственного экземпляра класса.\n\n**Применение:** Когда необходим строгий контроль над доступом к общему ресурсу.\n\n## Структурные паттерны\n\n### 1. Адаптер (Adapter)\nПреобразует интерфейс одного класса в интерфейс, ожидаемый клиентом. Позволяет классам с несовместимыми интерфейсами работать вместе.\n\n**Назначение:** Совместимость несовместимых интерфейсов.\n\n**Применение:** При интеграции нового кода со старым.\n\n### 2. Мост (Bridge)\nРазделяет абстракцию и реализацию так, чтобы они могли изменяться независимо друг от друга.\n\n**Назначение:** Разделение интерфейса и реализации.\n\n**Применение:** Для предотвращения роста иерархии классов.\n\n### 3. Компоновщик (Composite)\nОбъединяет объекты в древовидные структуры для представления иерархий часть-целое. Позволяет клиентам единообразно трактовать отдельные объекты и их композиции.\n\n**Назначение:** Работа с древовидными структурами.\n\n**Применение:** Для представления иерархических структур.\n\n### 4. Декоратор (Decorator)\nДинамически добавляет объекту новые обязанности. Является гибкой альтернативой наследованию для расширения функциональности.\n\n**Назначение:** Динамическое расширение функциональности.\n\n**Применение:** Когда нельзя использовать наследование.\n\n### 5. Фасад (Facade)\nПредоставляет унифицированный интерфейс к набору интерфейсов в подсистеме. Определяет интерфейс более высокого уровня, который упрощает использование подсистемы.\n\n**Назначение:** Упрощение сложных систем.\n\n**Применение:** Для предоставления простого интерфейса к сложной подсистеме.\n\n### 6. Приспособленец (Flyweight)\nИспользует разделение для эффективной поддержки множества мелких объектов.\n\n**Назначение:** Оптимизация использования памяти.\n\n**Применение:** При работе с большим количеством объектов.\n\n### 7. Заместитель (Proxy)\nПредоставляет объект-заместитель, который контролирует доступ к другому объекту.\n\n**Назначение:** Контроль доступа к объекту.\n\n**Применение:** Для ленивой инициализации, кэширования, логирования.\n\n## Поведенческие паттерны\n\n### 1. Цепочка обязанностей (Chain of Responsibility)\nПозволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос, и передает его дальше.\n\n**Назначение:** Последовательная обработка запросов.\n\n**Применение:** Для обработки событий в UI.\n\n### 2. Команда (Command)\nИнкапсулирует запрос как объект, позволяя тем самым параметризовать клиентов для выполнения различных запросов, ставить запросы в очередь или протоколировать их.\n\n**Назначение:** Инкапсуляция запросов.\n\n**Применение:** Для реализации отмены операций.\n\n### 3. Интерпретатор (Interpreter)\nОпределяет грамматику простого языка и интерпретатор для предложений этого языка.\n\n**Назначение:** Интерпретация языков.\n\n**Применение:** Для DSL (Domain-Specific Languages).\n\n### 4. Итератор (Iterator)\nПредоставляет способ последовательного доступа к элементам составного объекта, не раскрывая его внутреннего представления.\n\n**Назначение:** Последовательный обход коллекций.\n\n**Применение:** Для работы с коллекциями данных.\n\n### 5. Посредник (Mediator)\nОпределяет объект, инкапсулирующий способ взаимодействия множества объектов. Посредник обеспечивает слабую связанность системы, избавляя объекты от необходимости явно ссылаться друг на друга.\n\n**Назначение:** Управление взаимодействием объектов.\n\n**Применение:** Для уменьшения связности между компонентами.\n\n### 6. Хранитель (Memento)\nНе нарушая инкапсуляции, фиксирует и выносит за пределы объекта его внутреннее состояние, чтобы позднее объект можно было восстановить в этом состоянии.\n\n**Назначение:** Сохранение и восстановление состояния.\n\n**Применение:** Для реализации функционала отмены действий.\n\n### 7. Наблюдатель (Observer)\nОпределяет зависимость «один ко многим» между объектами так, что при изменении состояния одного объекта все зависящие от него объекты уведомляются и обновляются автоматически.\n\n**Назначение:** Реакция на изменения состояния.\n\n**Применение:** В событийно-ориентированных системах.\n\n### 8. Состояние (State)\nПозволяет объекту изменять свое поведение при изменении его внутреннего состояния. Создается впечатление, что объект изменил свой класс.\n\n**Назначение:** Управление поведением в зависимости от состояния.\n\n**Применение:** Для объектов с множеством состояний.\n\n### 9. Стратегия (Strategy)\nОпределяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми. Позволяет изменять алгоритмы независимо от клиентов, которые ими пользуются.\n\n**Назначение:** Инкапсуляция алгоритмов.\n\n**Применение:** Когда есть несколько вариантов решения задачи.\n\n### 10. Шаблонный метод (Template Method)\nОпределяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Позволяет подклассам переопределять шаги алгоритма, не меняя его структуры.\n\n**Назначение:** Определение структуры алгоритма.\n\n**Применение:** Для алгоритмов с изменяющимися шагами.\n\n### 11. Посетитель (Visitor)\nОписывает операцию, выполняемую с каждым объектом из некоторой структуры. Посетитель позволяет определить новую операцию, не изменяя классы объектов, над которыми эта операция выполняется.\n\n**Назначение:** Добавление операций к объектам.\n\n**Применение:** Для работы с сложными структурами объектов.\n\n## Принципы проектирования\n\n### 1. Принцип единственной ответственности (SRP)\nКласс должен иметь только одну причину для изменения. Каждый класс должен отвечать за одну конкретную функциональность.\n\n### 2. Принцип открытости/закрытости (OCP)\nПрограммные сущности должны быть открыты для расширения, но закрыты для модификации. Можно добавлять новую функциональность, не изменяя существующий код.\n\n### 3. Принцип подстановки Барбары Лисков (LSP)\nОбъекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы.\n\n### 4. Принцип разделения интерфейса (ISP)\nМного специализированных интерфейсов лучше, чем один общий. Клиенты не должны зависеть от методов, которые они не используют.\n\n### 5. Принцип инверсии зависимостей (DIP)\nМодули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.\n\n## Антипаттерны\n\n### 1. Божественный объект (God Object)\nОбъект, который знает или делает слишком много. Нарушает принцип единственной ответственности.\n\n### 2. Спагетти-код (Spaghetti Code)\nКод без четкой структуры, с запутанными связями и зависимостями.\n\n### 3. Жесткая связность (Tight Coupling)\nСильная зависимость между компонентами, делающая систему негибкой.\n\n### 4. Преждевременная оптимизация\nОптимизация кода до того, как выявлены реальные узкие места.\n\n### 5. Изобретение велосипеда\nСоздание собственных решений вместо использования проверенных паттернов и библиотек.\n\n## Паттерны в современных фреймворках\n\n### React\n- **Higher-Order Components (HOC)** — декоратор\n- **Render Props** — стратегия\n- **Hooks** — различные паттерны\n- **Context** — посредник\n\n### Vue.js\n- **Mixins** — стратегия\n- **Slots** — компоновщик\n- **Provide/Inject** — посредник\n\n### Angular\n- **Services** — синглтон\n- **Dependency Injection** — стратегия\n- **Directives** — декоратор\n\n## Критерии выбора паттернов\n\n### Когда использовать паттерны:\n1. При решении типичных проблем проектирования\n2. Для улучшения читаемости и поддерживаемости кода\n3. Для снижения связанности компонентов\n4. При работе в команде для стандартизации подходов\n\n### Когда не использовать паттерны:\n1. Для простых задач, где паттерн усложняет код\n2. Когда нет понимания проблемы, которую решает паттерн\n3. Для следования моде без реальной необходимости\n4. Когда паттерн противоречит архитектуре проекта\n\n## Лучшие практики применения паттернов\n\n1. **Начинайте с простых решений** — не усложняйте без необходимости\n2. **Понимайте проблему** прежде чем применять паттерн\n3. **Адаптируйте паттерны** под конкретные задачи\n4. **Документируйте использование** паттернов в коде\n5. **Избегайте излишней абстракции** — балансируйте между гибкостью и сложностью\n6. **Тестируйте изолированно** — каждый паттерн должен быть протестирован\n7. **Следите за производительностью** — некоторые паттерны могут замедлять выполнение\n8. **Обучайте команду** — единое понимание паттернов в проекте\n\n## Эволюция паттернов в JavaScript\n\n### Традиционные паттерны\nОснованы на классических объектно-ориентированных принципах, адаптированных для JavaScript.\n\n### Функциональные паттерны\nИспользуют возможности функционального программирования: каррирование, композиция, монады.\n\n### Реактивные паттерны\nДля работы с асинхронными потоками данных: Observable, Pub/Sub.\n\n### Современные паттерны\nСочетание различных парадигм, адаптированных под современные фреймворки и библиотеки.\n\n## Заключение\n\nПаттерны проектирования — это мощный инструмент для создания качественного программного обеспечения. Они представляют собой коллекцию проверенных решений для типичных проблем проектирования. Однако важно понимать, что паттерны — не панацея, а инструмент, который нужно применять с умом.\n\nКлючевые аспекты успешного использования паттернов:\n- Глубокое понимание решаемой проблемы\n- Знание преимуществ и недостатков каждого паттерна\n- Умение адаптировать паттерны под конкретные нужды\n- Баланс между гибкостью и сложностью\n- Постоянное обучение и изучение новых подходов\n\nПравильное применение паттернов позволяет создавать код, который легче понимать, тестировать, поддерживать и масштабировать.",
  
  "points": [
    "Категории паттернов: порождающие, структурные, поведенческие",
    "Порождающие паттерны: фабрика, строитель, синглтон",
    "Структурные паттерны: адаптер, декоратор, фасад, прокси",
    "Поведенческие паттерны: наблюдатель, стратегия, состояние",
    "Принципы SOLID в контексте паттернов",
    "Антипаттерны и как их избегать",
    "Паттерны в современных фреймворках",
    "Критерии выбора паттернов",
    "Лучшие практики применения",
    "Эволюция паттернов в JavaScript"
  ],
  
  "lesson": {
    "slug": "performance",
    "title": "Оптимизация производительности"
  }
}