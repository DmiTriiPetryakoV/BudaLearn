{
  "slug": "oop-classes",
  "title": "Объектно-ориентированное программирование в JavaScript",
  "description": "Изучите принципы ООП, работу с классами, наследование, инкапсуляцию и полиморфизм в JavaScript.",
  "difficulty": "intermediate",
  "duration": 45,
  "time":15,
  "theory": "## Введение в ООП\n\nОбъектно-ориентированное программирование (ООП) — это парадигма программирования, основанная на концепции объектов, которые содержат данные и методы для работы с этими данными.\n\n## Основные принципы ООП\n\n### 1. Инкапсуляция\nСокрытие внутренней реализации и предоставление публичного интерфейса.\n\n### 2. Наследование\nСоздание новых классов на основе существующих.\n\n### 3. Полиморфизм\nВозможность объектов с одинаковым интерфейсом иметь разную реализацию.\n\n### 4. Абстракция\nСоздание упрощенных моделей сложных систем.\n\n## Прототипное наследование в JavaScript\n\nJavaScript использует прототипную модель наследования, где объекты наследуют свойства от других объектов (прототипов).\n\n```javascript\n// Прототипное наследование\nconst animal = {\n    eat() {\n        console.log('Ест');\n    }\n};\n\nconst dog = Object.create(animal);\ndog.bark = function() {\n    console.log('Гав!');\n};\n\ndog.eat(); // Ест (наследуется)\ndog.bark(); // Гав!\n```\n\n## Классы ES6+\n\n### Базовый синтаксис классов\n\n```javascript\nclass Person {\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    greet() {\n        return `Привет, меня зовут ${this.name}`;\n    }\n}\n\nconst anna = new Person('Анна', 25);\nconsole.log(anna.greet()); // Привет, меня зовут Анна\n```\n\n### Геттеры и сеттеры\n\n```javascript\nclass User {\n    constructor(firstName, lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n    }\n    \n    get fullName() {\n        return `${this.firstName} ${this.lastName}`;\n    }\n    \n    set fullName(value) {\n        const [firstName, lastName] = value.split(' ');\n        this.firstName = firstName;\n        this.lastName = lastName || '';\n    }\n}\n\nconst user = new User('Иван', 'Петров');\nconsole.log(user.fullName); // Иван Петров\nuser.fullName = 'Анна Иванова';\nconsole.log(user.firstName); // Анна\n```\n\n### Статические методы и свойства\n\n```javascript\nclass MathHelper {\n    static PI = 3.14159;\n    \n    static sum(a, b) {\n        return a + b;\n    }\n    \n    static average(numbers) {\n        return numbers.reduce((a, b) => a + b, 0) / numbers.length;\n    }\n}\n\nconsole.log(MathHelper.PI); // 3.14159\nconsole.log(MathHelper.sum(5, 3)); // 8\nconsole.log(MathHelper.average([1, 2, 3, 4, 5])); // 3\n```\n\n## Наследование\n\n### Базовое наследование\n\n```javascript\nclass Animal {\n    constructor(name) {\n        this.name = name;\n    }\n    \n    speak() {\n        console.log(`${this.name} издает звук`);\n    }\n}\n\nclass Dog extends Animal {\n    constructor(name, breed) {\n        super(name); // Вызов конструктора родителя\n        this.breed = breed;\n    }\n    \n    speak() {\n        console.log(`${this.name} говорит: Гав!`);\n    }\n    \n    fetch() {\n        console.log(`${this.name} принес палку`);\n    }\n}\n\nconst dog = new Dog('Бобик', 'Дворняжка');\ndog.speak(); // Бобик говорит: Гав!\ndog.fetch(); // Бобик принес палку\n```\n\n### Переопределение методов\n\n```javascript\nclass Vehicle {\n    move() {\n        console.log('Двигается');\n    }\n}\n\nclass Car extends Vehicle {\n    move() {\n        super.move(); // Вызов родительского метода\n        console.log('По дороге');\n    }\n}\n\nclass Plane extends Vehicle {\n    move() {\n        console.log('Летит по воздуху');\n    }\n}\n\nconst car = new Car();\ncar.move(); // Двигается\\nПо дороге\n\nconst plane = new Plane();\nplane.move(); // Летит по воздуху\n```\n\n## Приватные поля и методы\n\n### Приватные поля (ES2022)\n\n```javascript\nclass BankAccount {\n    #balance = 0; // Приватное поле\n    \n    constructor(owner, initialBalance = 0) {\n        this.owner = owner;\n        this.#balance = initialBalance;\n    }\n    \n    deposit(amount) {\n        if (amount > 0) {\n            this.#balance += amount;\n            console.log(`Внесено: ${amount}`);\n        }\n    }\n    \n    withdraw(amount) {\n        if (amount > 0 && amount <= this.#balance) {\n            this.#balance -= amount;\n            console.log(`Снято: ${amount}`);\n        }\n    }\n    \n    getBalance() {\n        return this.#balance;\n    }\n}\n\nconst account = new BankAccount('Анна', 1000);\naccount.deposit(500);\nconsole.log(account.getBalance()); // 1500\n// account.#balance = 10000; // Ошибка! Поле приватное\n```\n\n### Приватные методы\n\n```javascript\nclass SecureSystem {\n    #validatePassword(password) {\n        return password.length >= 8;\n    }\n    \n    login(username, password) {\n        if (this.#validatePassword(password)) {\n            console.log(`${username} вошел в систему`);\n        } else {\n            console.log('Неверный пароль');\n        }\n    }\n}\n```\n\n## Паттерны проектирования ООП\n\n### Фабричный метод\n\n```javascript\nclass Product {\n    constructor(name, price) {\n        this.name = name;\n        this.price = price;\n    }\n}\n\nclass ProductFactory {\n    static createBook(name, author) {\n        const book = new Product(name, 500);\n        book.author = author;\n        book.type = 'book';\n        return book;\n    }\n    \n    static createElectronics(name, warranty) {\n        const electronics = new Product(name, 10000);\n        electronics.warranty = warranty;\n        electronics.type = 'electronics';\n        return electronics;\n    }\n}\n\nconst book = ProductFactory.createBook('Война и мир', 'Толстой');\nconst laptop = ProductFactory.createElectronics('Ноутбук', '2 года');\n```\n\n### Одиночка (Singleton)\n\n```javascript\nclass Logger {\n    static instance = null;\n    \n    constructor() {\n        if (Logger.instance) {\n            return Logger.instance;\n        }\n        \n        this.logs = [];\n        Logger.instance = this;\n    }\n    \n    log(message) {\n        const timestamp = new Date().toISOString();\n        this.logs.push({ timestamp, message });\n        console.log(`[${timestamp}] ${message}`);\n    }\n    \n    getLogs() {\n        return this.logs;\n    }\n}\n\nconst logger1 = new Logger();\nconst logger2 = new Logger();\nconsole.log(logger1 === logger2); // true\n```\n\n### Наблюдатель (Observer)\n\n```javascript\nclass Observable {\n    constructor() {\n        this.observers = [];\n    }\n    \n    subscribe(observer) {\n        this.observers.push(observer);\n    }\n    \n    unsubscribe(observer) {\n        this.observers = this.observers.filter(obs => obs !== observer);\n    }\n    \n    notify(data) {\n        this.observers.forEach(observer => observer.update(data));\n    }\n}\n\nclass Observer {\n    constructor(name) {\n        this.name = name;\n    }\n    \n    update(data) {\n        console.log(`${this.name} получил: ${data}`);\n    }\n}\n\nconst observable = new Observable();\nconst observer1 = new Observer('Первый');\nconst observer2 = new Observer('Второй');\n\nobservable.subscribe(observer1);\nobservable.subscribe(observer2);\nobservable.notify('Новые данные');\n```\n\n## Композиция vs Наследование\n\n### Наследование (is-a)\n\n```javascript\nclass Animal {\n    breathe() {\n        console.log('Дышит');\n    }\n}\n\nclass Fish extends Animal {\n    swim() {\n        console.log('Плавает');\n    }\n}\n\n// Рыба - это животное\n```\n\n### Композиция (has-a)\n\n```javascript\nclass Engine {\n    start() {\n        console.log('Двигатель запущен');\n    }\n}\n\nclass Wheels {\n    rotate() {\n        console.log('Колеса крутятся');\n    }\n}\n\nclass Car {\n    constructor() {\n        this.engine = new Engine();\n        this.wheels = new Wheels();\n    }\n    \n    drive() {\n        this.engine.start();\n        this.wheels.rotate();\n        console.log('Машина едет');\n    }\n}\n\n// Машина имеет двигатель и колеса\n```\n\n## Абстрактные классы\n\nВ JavaScript нет нативной поддержки абстрактных классов, но можно имитировать:\n\n```javascript\nclass AbstractShape {\n    constructor() {\n        if (new.target === AbstractShape) {\n            throw new Error('Нельзя создать экземпляр абстрактного класса');\n        }\n    }\n    \n    getArea() {\n        throw new Error('Метод getArea должен быть реализован');\n    }\n    \n    getPerimeter() {\n        throw new Error('Метод getPerimeter должен быть реализован');\n    }\n}\n\nclass Circle extends AbstractShape {\n    constructor(radius) {\n        super();\n        this.radius = radius;\n    }\n    \n    getArea() {\n        return Math.PI * this.radius * this.radius;\n    }\n    \n    getPerimeter() {\n        return 2 * Math.PI * this.radius;\n    }\n}\n\n// const shape = new AbstractShape(); // Ошибка\nconst circle = new Circle(5);\nconsole.log(circle.getArea()); // 78.53981633974483\n```\n\n## Миксины\n\nМиксины позволяют добавлять функциональность классам без наследования.\n\n```javascript\n// Миксин для логирования\nconst LoggerMixin = Base => class extends Base {\n    log(message) {\n        console.log(`[${this.constructor.name}] ${message}`);\n    }\n};\n\n// Миксин для валидации\nconst ValidatorMixin = Base => class extends Base {\n    validateEmail(email) {\n        return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email);\n    }\n};\n\nclass User {\n    constructor(email) {\n        this.email = email;\n    }\n}\n\n// Применение миксинов\nconst EnhancedUser = LoggerMixin(ValidatorMixin(User));\n\nconst user = new EnhancedUser('test@example.com');\nuser.log('Создан пользователь'); // [EnhancedUser] Создан пользователь\nconsole.log(user.validateEmail('test@example.com')); // true\n```\n\n## Интерфейсы и полиморфизм\n\n### Интерфейсы через утиную типизацию\n\n```javascript\n// В JavaScript интерфейсы реализуются неявно\nclass Bird {\n    fly() {\n        console.log('Птица летит');\n    }\n}\n\nclass Airplane {\n    fly() {\n        console.log('Самолет летит');\n    }\n}\n\nfunction makeItFly(flyingObject) {\n    if (typeof flyingObject.fly === 'function') {\n        flyingObject.fly();\n    }\n}\n\nconst bird = new Bird();\nconst airplane = new Airplane();\n\nmakeItFly(bird); // Птица летит\nmakeItFly(airplane); // Самолет летит\n```\n\n## Инкапсуляция через замыкания\n\n```javascript\nfunction createCounter() {\n    let count = 0; // Приватная переменная\n    \n    return {\n        increment() {\n            count++;\n            return count;\n        },\n        \n        decrement() {\n            count--;\n            return count;\n        },\n        \n        getCount() {\n            return count;\n        }\n    };\n}\n\nconst counter = createCounter();\ncounter.increment(); // 1\ncounter.increment(); // 2\nconsole.log(counter.getCount()); // 2\n// counter.count = 10; // Не работает\n```\n\n## Принципы SOLID\n\n### 1. Single Responsibility (Принцип единственной ответственности)\nКласс должен иметь только одну причину для изменения.\n\n### 2. Open/Closed (Принцип открытости/закрытости)\nКлассы должны быть открыты для расширения, но закрыты для модификации.\n\n### 3. Liskov Substitution (Принцип подстановки Барбары Лисков)\nОбъекты должны быть заменяемыми экземплярами своих базовых классов.\n\n### 4. Interface Segregation (Принцип разделения интерфейса)\nМного специализированных интерфейсов лучше одного общего.\n\n### 5. Dependency Inversion (Принцип инверсии зависимостей)\nЗависимость от абстракций, а не от конкретных реализаций.\n\n## Пример применения SOLID\n\n```javascript\n// Принцип единственной ответственности\nclass User {\n    constructor(name, email) {\n        this.name = name;\n        this.email = email;\n    }\n}\n\nclass UserRepository {\n    save(user) {\n        // Сохранение в базу данных\n    }\n}\n\nclass EmailService {\n    sendWelcomeEmail(user) {\n        // Отправка email\n    }\n}\n\n// Разделение ответственности между классами\n```\n\n## Лучшие практики ООП в JavaScript\n\n1. **Используйте классы для сложных сущностей** с состоянием и поведением\n2. **Предпочитайте композицию наследованию** где это возможно\n3. **Соблюдайте инкапсуляцию** через приватные поля и методы\n4. **Следуйте принципам SOLID** для создания поддерживаемого кода\n5. **Используйте фабричные методы** для сложного создания объектов\n6. **Избегайте глубоких иерархий наследования** (максимум 2-3 уровня)\n7. **Применяйте полиморфизм** для гибкости кода\n8. **Документируйте публичный интерфейс** классов\n9. **Тестируйте классы изолированно**\n10. **Используйте статические методы** для утилитарных функций\n\n## Заключение\n\nООП в JavaScript сочетает классические принципы объектно-ориентированного программирования с уникальными особенностями языка. Современный синтаксис классов, приватные поля, наследование и другие возможности позволяют создавать чистые, поддерживаемые и масштабируемые приложения.\n\nКлючевые преимущества ООП в JavaScript:\n- Четкая организация кода\n- Повторное использование через наследование и композицию\n- Инкапсуляция и сокрытие сложности\n- Легкость тестирования и поддержки\n- Гибкость через полиморфизм\n\nОсвоение ООП принципов критически важно для разработки сложных приложений и карьерного роста JavaScript-разработчика.",
  
  "points": [
    "Основные принципы ООП: инкапсуляция, наследование, полиморфизм",
    "Классы ES6: конструкторы, методы, статические члены",
    "Наследование и переопределение методов",
    "Приватные поля и методы (ES2022+)",
    "Геттеры и сеттеры",
    "Паттерны проектирования: фабрика, синглтон, наблюдатель",
    "Композиция vs наследование",
    "Абстрактные классы и интерфейсы",
    "Миксины для расширения функциональности",
    "Принципы SOLID",
    "Лучшие практики ООП в JavaScript"
  ],
  
  "lesson": {
    "slug": "testing",
    "title": "Тестирование JavaScript кода"
  }
}