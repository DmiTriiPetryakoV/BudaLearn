{
  "slug": "modules",
  "title": "Модули в JavaScript",
  "description": "Изучите систему модулей ES6, импорт/экспорт, динамические импорты и организацию кода в современном JavaScript.",
  "difficulty": "intermediate",
  "duration": 35,
    "time":15,
  "theory": "## Введение в модули\n\nМодули — это способ организации кода в независимые, повторно используемые единицы. До ES6 в JavaScript использовались различные подходы к модульности (CommonJS, AMD), но с ES6 появилась стандартизированная система модулей.\n\n## Преимущества модулей\n\n1. **Изоляция кода** — каждый модуль имеет свою область видимости\n2. **Повторное использование** — модули можно импортировать в разных местах\n3. **Организация** — код разделен на логические единицы\n4. **Управление зависимостями** — явное указание импортов\n5. **Деревошакинг** — удаление неиспользуемого кода\n\n## Синтаксис экспорта\n\n### Именованный экспорт\n\n```javascript\n// math.js\n\n// Экспорт переменных\nexport const PI = 3.14159;\nexport const E = 2.71828;\n\n// Экспорт функций\nexport function add(a, b) {\n    return a + b;\n}\n\nexport function multiply(a, b) {\n    return a * b;\n}\n\n// Экспорт классов\nexport class Calculator {\n    constructor() {\n        this.result = 0;\n    }\n    \n    add(x) {\n        this.result += x;\n        return this.result;\n    }\n}\n```\n\n### Групповой экспорт\n\n```javascript\n// Можно экспортировать всё в конце файла\nconst PI = 3.14159;\nconst E = 2.71828;\n\nfunction add(a, b) {\n    return a + b;\n}\n\n// Групповой экспорт\nexport { PI, E, add };\n\n// Экспорт с переименованием\nexport { PI as PiValue, E as EulerNumber };\n```\n\n### Экспорт по умолчанию\n\n```javascript\n// Каждый модуль может иметь только один default экспорт\n\n// Экспорт функции по умолчанию\nexport default function subtract(a, b) {\n    return a - b;\n}\n\n// Или альтернативный синтаксис\nfunction divide(a, b) {\n    return a / b;\n}\n\nexport default divide;\n\n// Экспорт класса по умолчанию\nexport default class MathHelper {\n    // ...\n}\n\n// Экспорт объекта по умолчанию\nexport default {\n    version: '1.0.0',\n    author: 'Team'\n};\n```\n\n### Комбинированный экспорт\n\n```javascript\n// Модуль может иметь как default, так и именованные экспорты\n\nexport const version = '1.0.0';\n\nexport function helper() {\n    return 'help';\n}\n\nexport default class MainClass {\n    // ...\n}\n```\n\n## Синтаксис импорта\n\n### Именованный импорт\n\n```javascript\n// Импорт конкретных имен\nimport { PI, add } from './math.js';\n\nconsole.log(PI); // 3.14159\nconsole.log(add(2, 3)); // 5\n```\n\n### Импорт с переименованием\n\n```javascript\nimport { PI as PiValue, add as sum } from './math.js';\n\nconsole.log(PiValue); // 3.14159\nconsole.log(sum(2, 3)); // 5\n```\n\n### Импорт всего модуля\n\n```javascript\nimport * as MathModule from './math.js';\n\nconsole.log(MathModule.PI); // 3.14159\nconsole.log(MathModule.add(2, 3)); // 5\nconsole.log(MathModule.default); // default экспорт, если есть\n```\n\n### Импорт по умолчанию\n\n```javascript\n// Для default экспорта не нужны фигурные скобки\nimport subtract from './math.js';\n\nconsole.log(subtract(5, 3)); // 2\n```\n\n### Комбинированный импорт\n\n```javascript\n// Импорт default и именованных экспортов\nimport Calculator, { PI, add } from './math.js';\n\nconst calc = new Calculator();\nconsole.log(PI); // 3.14159\nconsole.log(add(2, 3)); // 5\n```\n\n## Динамический импорт\n\n### Загрузка модулей по требованию\n\n```javascript\n// Статический импорт (загружается сразу)\nimport { heavyFunction } from './heavyModule.js';\n\n// Динамический импорт (загружается по необходимости)\nasync function loadModuleWhenNeeded() {\n    const module = await import('./heavyModule.js');\n    module.heavyFunction();\n}\n\n// Использование then\nimport('./module.js').then(module => {\n    module.someFunction();\n});\n```\n\n### Условная загрузка\n\n```javascript\nasync function loadFeature(featureName) {\n    if (featureName === 'analytics') {\n        const analytics = await import('./analytics.js');\n        analytics.trackEvent('feature_loaded');\n    } else if (featureName === 'charts') {\n        const charts = await import('./charts.js');\n        charts.renderChart();\n    }\n}\n```\n\n## Модули в браузере\n\n### Использование type=\"module\"\n\n```html\n<!-- Подключение модуля в HTML -->\n<script type=\"module\" src=\"main.js\"></script>\n\n<!-- Встроенный модуль -->\n<script type=\"module\">\n    import { add } from './math.js';\n    console.log(add(2, 3));\n</script>\n```\n\n### Особенности браузерных модулей\n\n1. **Строгий режим по умолчанию**\n2. **Своя область видимости** — переменные не попадают в глобальную область\n3. **Отложенное выполнение** — выполняется после парсинга документа\n4. **CORS** — модули загружаются с CORS заголовками\n\n## Циклические зависимости\n\n### Проблема циклических импортов\n\n```javascript\n// a.js\nimport { b } from './b.js';\nexport const a = 'A' + b;\n\n// b.js\nimport { a } from './a.js';\nexport const b = 'B' + a; // Бесконечная рекурсия!\n```\n\n### Решение циклических зависимостей\n\n```javascript\n// Правильный подход: разделение интерфейса и реализации\n\n// constants.js - общие константы\nexport const TYPES = {\n    USER: 'user',\n    ADMIN: 'admin'\n};\n\n// user.js - использует константы\nimport { TYPES } from './constants.js';\nexport class User {\n    constructor(type = TYPES.USER) {\n        this.type = type;\n    }\n}\n\n// admin.js - тоже использует константы\nimport { TYPES } from './constants.js';\nexport class Admin {\n    constructor() {\n        this.type = TYPES.ADMIN;\n    }\n}\n```\n\n## Модули в Node.js\n\n### Поддержка ES6 модулей\n\n```javascript\n// package.json\n{\n    \"type\": \"module\" // Включает поддержку ES6 модулей\n}\n\n// Или использовать расширение .mjs\n// math.mjs\nexport const PI = 3.14159;\n\n// app.mjs\nimport { PI } from './math.mjs';\nconsole.log(PI);\n```\n\n### Совместимость с CommonJS\n\n```javascript\n// Импорт CommonJS модуля в ES6 модуле\nimport fs from 'fs'; // Работает\nimport { readFile } from 'fs/promises'; // Тоже работает\n\n// Динамический импорт CommonJS\nconst { someFunction } = await import('./commonjs-module.cjs');\n```\n\n## Организация модулей\n\n### Структура проекта\n\n```\nproject/\n├── src/\n│   ├── components/     # UI компоненты\n│   │   ├── Button.js\n│   │   ├── Modal.js\n│   │   └── index.js    # Баррель-экспорт\n│   ├── utils/          # Вспомогательные функции\n│   │   ├── format.js\n│   │   ├── validate.js\n│   │   └── index.js\n│   ├── services/       # Сервисы и API\n│   │   └── api.js\n│   ├── constants/      # Константы\n│   │   └── config.js\n│   └── index.js        # Точка входа\n├── package.json\n└── index.html\n```\n\n### Баррель-экспорт (Barrel exports)\n\n```javascript\n// utils/index.js\n\n// Реэкспорт всех модулей\n\nexport { formatDate } from './format.js';\nexport { validateEmail } from './validate.js';\nexport { debounce, throttle } from './performance.js';\n\nexport * from './format.js';\nexport * from './validate.js';\n\n// Затем импорт из барреля\nimport { formatDate, validateEmail } from './utils/index.js';\n// Или просто\nimport { formatDate, validateEmail } from './utils';\n```\n\n## Деревошакинг (Tree Shaking)\n\n### Удаление неиспользуемого кода\n\nДеревошакинг — это процесс удаления неиспользуемого кода при сборке. Работает только с ES6 модулями.\n\n```javascript\n// module.js\nexport function usedFunction() {\n    return 'используется';\n}\n\nexport function unusedFunction() {\n    return 'не используется';\n}\n\n// main.js\nimport { usedFunction } from './module.js';\nconsole.log(usedFunction());\n\n// При сборке unusedFunction будет удалена\n```\n\n### Условия для деревошакинга\n\n1. Использование ES6 модулей\n2. Отсутствие побочных эффектов\n3. Статические импорты/экспорты\n\n## Побочные эффекты (Side Effects)\n\n### Модули с побочными эффектами\n\n```javascript\n// Модуль с побочным эффектом (регистрация в глобальном объекте)\nwindow.myLibrary = {\n    version: '1.0.0'\n};\n\n// Чтобы сборщик не удалял этот код\nexport default {};\n\n// Или в package.json\n{\n    \"sideEffects\": [\n        \"**/*.css\",\n        \"**/*.scss\",\n        \"src/polyfills.js\"\n    ]\n}\n```\n\n## Ленивая загрузка (Lazy Loading)\n\n### Загрузка по требованию\n\n```javascript\n// Ленивая загрузка тяжелого модуля\nconst loadHeavyModule = async () => {\n    const module = await import(\n        /* webpackChunkName: \"heavy-module\" */ \n        './heavyModule.js'\n    );\n    return module;\n};\n\n// Ленивая загрузка компонента\nconst LazyComponent = React.lazy(() => import('./HeavyComponent.js'));\n```\n\n## Переименование и реэкспорт\n\n### Реэкспорт\n\n```javascript\n// Реэкспорт из другого модуля\n\nexport { something } from './other-module.js';\n\nexport { default as DefaultExport } from './module.js';\n\nexport * from './utils.js'; // Реэкспорт всего\n\nexport * as Utils from './utils.js'; // ES2020\n```\n\n## Работа с типами в TypeScript\n\n### Типизированные модули\n\n```typescript\n// math.ts\nexport const PI: number = 3.14159;\n\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n\n// Импорт с типами\nimport { PI, add } from './math.js';\n\nconst result: number = add(2, 3);\n```\n\n## Лучшие практики\n\n### 1. Используйте именованные экспорты по умолчанию\nИменованные экспорты лучше для деревошакинга и рефакторинга.\n\n### 2. Избегайте default экспортов для утилит\n\n### 3. Организуйте модули по функциональности\n\n### 4. Используйте абсолютные пути для импортов\n\n```javascript\n// Плохо\nimport { something } from '../../../../utils/helpers.js';\n\n// Хорошо\nimport { something } from '@/utils/helpers.js';\n```\n\n### 5. Минимизируйте циклические зависимости\n\n### 6. Используйте динамические импорты для больших модулей\n\n### 7. Документируйте публичный интерфейс модулей\n\n### 8. Тестируйте модули изолированно\n\n### 9. Используйте баррель-экспорты для папок\n\n### 10. Следите за размером модулей\n\n## Инструменты\n\n### Сборщики модулей\n- **Webpack** — самый популярный сборщик\n- **Rollup** — ориентирован на библиотеки\n- **Parcel** — нулевая конфигурация\n- **Vite** — современный быстрый инструмент\n\n### Линтеры\n- **ESLint** с правилами для импортов\n- **import/export** правила\n\n## Заключение\n\nМодули ES6 — это фундаментальная технология современной JavaScript разработки. Они обеспечивают четкую организацию кода, управление зависимостями и возможности для оптимизации.\n\nКлючевые преимущества:\n- Стандартизированный синтаксис\n- Статический анализ кода\n- Деревошакинг и оптимизация\n- Изоляция и повторное использование\n- Динамическая загрузка\n\nПонимание системы модулей необходимо для создания масштабируемых и поддерживаемых приложений.",
  
  "points": [
    "Синтаксис экспорта: именованный, default, групповой",
    "Синтаксис импорта: именованный, default, импорт всего модуля",
    "Динамические импорты и ленивая загрузка",
    "Модули в браузере: type=\"module\"",
    "Циклические зависимости и их решение",
    "Модули в Node.js",
    "Организация кода: структура проектов",
    "Баррель-экспорт",
    "Деревошакинг и оптимизация сборки",
    "Побочные эффекты модулей",
    "Лучшие практики работы с модулями"
  ],
  
  "lesson": {
    "slug": "testing",
    "title": "Тестирование JavaScript кода"
  }
}